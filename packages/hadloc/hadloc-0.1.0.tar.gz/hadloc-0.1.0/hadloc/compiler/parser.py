from .tokenizer import Token
from hadloc.error import CompilerException


class Parser:
    """
    Parses a J code file, given the list of tokens from the file. These tokens are generated using the tokenizer.
    The parser generates an abstract syntax tree using ASTNode objects to represent the structure of the code.
    This is done using a series of functions, each parses a single grammatical element. For example, the function
    class_declaration parses a class declaration and returns the ASTNode it generated. To parse a given element, the
    appropriate function should be passed into the parse function. This deals with adding the node to the tree, and
    resets the index if the parsing fails. The one exception to this is the parse_program function. This should be
    classed directly, and will return the root of the generated abstract syntax tree, as an ASTNode

    Attributes:
        ast (ASTNode): The parent node of the abstract syntax tree generated from parsing the tokens
        index (int): The index of the token that is currently being parsed
        tokens (tuple<Token, CodeObject>): List of tokens generated from the tokenizer

    Args:
        tokens (list<tuple<str, CodeObject>>): A list of tokens generated by the tokenizer. Each element is a tuple
            consisting of the token type as a string, and the token value as a CodeObject
    """

    def __init__(self, tokens):
        self.index = 0
        self.tokens = tokens
        self.ast = self.parse_program()

    def get_type(self, offset=0):
        """
        Returns the type of the token offset by a given amount from the token currently being parsed. If the requested
        token is out of bounds of the tokens array, then an empty string is returned

        Args:
            offset (int): the offset from the current token

        Returns:
             (str) the type of the token offset by a given amount from the token currently being parsed, or an
             empty string if the given offset is out of bounds
        """
        if self.index + offset >= len(self.tokens):
            return ''
        return self.tokens[self.index + offset][0]

    def raise_error(self, err_type, err_msg, offset=0, missing_msg=None):
        """
        Raises an error with a given type, message and location. Handles the case where the error location is a None
        token (doesn't exist) by using the token beforehand. An optional error message can be supplied for when this
        occurs, allowing for messages to behave differently depending on of a token is missing, or just wrong.

        Args:
            err_type (int): The type of the error message
            err_msg (str): Error message to display to the user
            offset (int): The offset from the current token, to the token that caused the error. This determines the
                token that the error message will highlight as having caused the error. This is optional and defaults to
                0 (the current token)
            missing_msg (str): Optional error message to display if the requested token (specified by offset) is None.
                If this is not supplied, it defaults to the message supplied by err_msg, meaning all errors show the
                same message
        Raises: Always raises a CompilerException
        """
        if missing_msg is None:
            missing_msg = err_msg
        if self.value(offset) is None:
            raise CompilerException(err_type, missing_msg, self.value(offset - 1))
        else:
            raise CompilerException(err_type, err_msg, self.value(offset))

    def value(self, offset=0):
        """
        Returns the value of the token offset by a given amount from the token currently being parsed. If the requested
        token is out of bounds of the tokens array, then None is returned

        Args:
            offset (int): the offset from the current token

        Returns:
             (CodeObject) the value of the token offset by a given amount from the token currently being parsed, or
             None if the given offset is out of bounds
        """
        if self.index + offset >= len(self.tokens):
            return None
        return self.tokens[self.index + offset][1]

    def match(self, value):
        """
        Simple helper function that returns True if the current tokens value matches the given argument. If the token
        matched, then it is advanced past, otherwise it is not, and False is returned
        """
        if self.value() == value:
            self.index += 1
            return True
        return False

    def parse_program(self):
        """
        Parses a program. A program is defined as follows
        Program         ::=  ImportDeclaration* ClassDeclaration*

        Creates a node with two children: Imports and Classes, both of which are lists of ASTNodes.

        Raises:
            CompilerException: if there is an error in the code to parse
        """
        node = ASTNode('Program', {'Imports': [], 'Classes': []})

        while self.parse(self.import_declaration, node, 'Imports'):
            pass

        while self.parse(self.class_declaration, node, 'Classes'):
            pass

        if self.index != len(self.tokens):
            raise CompilerException(CompilerException.SYNTAX, "Unexpected token", self.value())

        return node

    def parse(self, function, parent, name=None):
        """
        Calls the provided function. Before calling the function, saves the value of self.index. If the function returns
        None, then the value of self.index is restored, and False is returned. If a node is returned, then it is added
        to the abstract syntax tree with the given parent, under the given name. All parsing should be done by passing
        the function that parses an element into this function, as it automatically deals with restoring the value of
        self.index if parsing fails, and automatically deals with adding the node to the tree.
        If the function passed in raises a CompilerException, it will be caught, self.index will be restored, and the
        Exception will be reraised, so that if a function wishes to catch exceptions, self.index will still remain
        unchanged

        Args:
            function (function or method): A function that parses the required grammar element. This function must
                return the ASTNode representing the grammar it parsed if its parsing was successful. If parsing is
                unsuccessful, this function should return None. In this case, the function does not need to restore the
                value of the index, as this function deals with that. Can raise a CompilerException if the code is found
                to contain errors
            parent (ASTNode): The node that is the parent of the node that this function will create. This
                function will add its node to this parent as a child
            name (str): The name with which this child should use
                when it adds itself to its parent

        Returns:
            bool: True if the given function successfully parsed its grammar element, False otherwise
        """
        saved = self.index
        try:
            node = function()
        except CompilerException as ce:
            self.index = saved
            raise ce
        if node is None:
            self.index = saved
            return False

        if name is None:
            name = node.name
        parent.addchild(name, node)
        return True

    def import_declaration(self):
        """
        An import declaration is defined as follows

        **ImportDeclaration**  ::=  'import' TypeName ';'

        Creates a node containing a single child:
            * Name - An ASTNode representing a TypeName

        Returns:
            ASTNode: The node generated by parsing the import declaration, or None if parsing failed
        """
        if not self.match('import'):
            return None
        node = ASTNode('ImportDeclaration')
        if not self.parse(self.type_name, node, 'Name'):
            raise CompilerException(CompilerException.SYNTAX, 'Expected type name after import keyword',
                                    self.value(-1))
        if not self.match(';'):
            raise CompilerException(CompilerException.SYNTAX, "Expected ';' after import declaration",
                                    self.value(-1))
        return node

    # TODO add inheritance to classes
    def class_declaration(self):
        """
        Parses a class declaration. A class declaration is defined as follows:

        | **ClassDeclaration**  ::=  'public'? 'class' Identifier Generics? ClassBody
        | **ClassBody**         ::=  '{' (FieldDeclaration | FunctionDeclaration | Constructor)* '}'

        A class declaration has 5 children:
            * PrivacyModifier - A CodeObject that is one of 'private', 'public' or None
            * Name - CodeObject that is a string containing the name of the class
            * FieldDeclarations - List of ASTNodes
            * FunctionDeclarations - List of ASTNodes
            * Constructors - List of ASTNodes
            * Generics - List of ASTNodes, each of which is a TypeParameter (defined in the generic function)

        Returns:
            ASTNode: The node generated by parsing the class declaration, or None if parsing failed
        """
        node = ASTNode('ClassDeclaration', {'Fields': [], 'Constructors': [], 'Functions': [], 'Generics': []})
        self.add_optional(node, ['public'], 'PrivacyModifier')

        if not self.match('class'):
            return None

        if not self.get_type() == Token.identifier:
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected class name after the 'class' keyword", self.value(-1))
        node.addchild('Name', self.value())
        self.index += 1

        if self.parse(self.generics, node, 'Generics'):
            node['Generics'] = node['Generics'][0]['Parameters']

        if not self.match('{'):
            raise CompilerException(CompilerException.SYNTAX, "Expected opening brace, '{', after a class declaration",
                                    self.value(-1))

        while self.parse(self.function_declaration, node, 'Functions') or \
                self.parse(self.constructor_declaration, node, 'Constructors') or \
                self.parse(self.field_declaration, node, 'Fields'):
            pass

        if not self.match('}'):
            self.raise_error(CompilerException.SYNTAX,
                             "Unexpected token in class body",
                             missing_msg="Expected closing brace, '}', after a class body")

        return node

    def generics(self):
        """
        Parses Generic type parameters.

        | **Generics**          ::=  '<' TypeParameter (',' TypeParameter)* '>'
        | **TypeParameter**     ::=  Identifier ('inherits' ReferenceType ((',' ReferenceType)* 'and' ReferenceType)?)?

        Creates a node with the following children
            - Parameters - List of ASTNodes of type TypeParameter

        TypeParameter nodes have the following children
            - Name - CodeObject containing the name of the type
            - Parents - List of ASTNodes containing ReferenceTypes

        Returns:
            ASTNode: The node generated by parsing the generic type parameters, or None if parsing failed
        """
        parent = ASTNode('Generics', {'Parameters': []})
        if not self.match('<'):
            return None

        more_parameters = True
        while more_parameters:
            if not self.get_type() == Token.identifier:
                if len(parent['Parameters']) == 0:
                    raise CompilerException(CompilerException.SYNTAX, "Must have at least one generic type name inside"
                                                                      " angle brackets", self.value(-1))
                else:
                    raise CompilerException(CompilerException.SYNTAX, "Expected another generic type name after comma",
                                            self.value(-1))

            child = ASTNode('TypeParameter', {'Name': self.value(), 'Parents': []})
            parent.addchild('Parameters', child)
            self.index += 1

            if not self.match('inherits'):
                more_parameters = self.match(',')
                continue

            if not self.parse(self.reference_type, child, 'Parents'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected type to inherit from after 'inherits' keyword", self.value(-1))

            possible_end = self.index
            while self.match(','):
                if not self.parse(self.reference_type, child, 'Parents'):
                    self.index = possible_end
                    child['Parents'] = [child['Parents'][0]]

            if self.match('and'):
                if not self.parse(self.reference_type, child, 'Parents'):
                    raise CompilerException(CompilerException.SYNTAX,
                                            "Expected another type to inherit from after 'and' keyword", self.value(-1))
            else:
                self.index = possible_end
                child['Parents'] = [child['Parents'][0]]

            more_parameters = self.match(',')

        if not self.match('>'):
            raise CompilerException(CompilerException.SYNTAX, "Expected closing angle bracket, '>', after class "
                                                              "generic parameters", self.value(-1))

        return parent

    def function_declaration(self):
        """
        Parses a function declaration, defined as follows

        | **FunctionDeclaration**   ::=  FunctionHeader FunctionBody
        | **FunctionHeader**        ::=  PrivacyModifier? 'static'? Identifier Generics? '(' ParameterList? ')'
                                         ('->' ReturnType)?
        | **PrivacyModifier**       ::=  'private' | 'public'
        | **ReturnType**            ::=  Type | 'void'
        | **FunctionBody**          ::=  '{' Statement* '}'

        A function declaration has the following children
            - PrivacyModifier - A CodeObject. May be None
            - Static - A CodeObject. May be None
            - Name - A CodeObject containing the name of the function
            - Parameters - ASTNode containing a ParameterList node. May be None if there are no parameters
            - ReturnType - An ASTNode of type Type, or a CodeObject is the return type is void. May be None
            - Statements - List of ASTNodes, each of which is a Statement

        Returns:
            ASTNode: The node generated by parsing the function declaration, or None if parsing failed
        """
        node = ASTNode('FunctionDeclaration', {'Statements': [], 'Parameters': None, 'Generics': []})
        self.add_optional(node, ['private', 'public', 'protected'], 'PrivacyModifier')
        self.add_optional(node, ['static'], 'Static')

        if not self.get_type() == Token.identifier:
            return None
        node.addchild('Name', self.value())
        self.index += 1

        if self.parse(self.generics, node, 'Generics'):
            node['Generics'] = node['Generics'][0]['Parameters']

        if not self.match('('):
            return None

        self.parse(self.parameter_list, node, 'Parameters')

        if not self.match(')'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected closing bracket, ')', after function arguments", self.value(-1))

        if self.match('->'):
            if self.match('void'):
                node.addchild('ReturnType', self.value(-1))
            elif not self.parse(self.type, node, 'ReturnType'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected return type after return arrow in function declaration",
                                        self.value(-1))

        else:
            node.addchild('ReturnType', None)

        if not self.match('{'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected opening brace, '{', after function header", self.value(-1))

        while self.parse(self.statement, node, 'Statements'):
            pass

        if not self.match('}'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected closing brace, '}', after function body", self.value(-1))

        return node

    def parameter_list(self, inferred=False):
        """
        Parses a parameter list, used in function declarations, and anonymous functions. This function can parse both
        inferred type parameter lists and explicit type parameter lists, determined by the inferred argument. Inferred
        parameters cannot have variadic parameters.

        | **ExplicitParameterList**     ::=  (Parameter (',' Parameter)* (',' VariadicParameter)?) | VariadicParameter
        | **InferredParameterList**     ::=  (InferredParameter (',' InferredParameter)*
        | **Parameter**                 ::=  Type Identifier ('=' VariableInitializer)?
        | **InferredParameter**         ::=  Identifier ('=' VariableInitializer)?
        | **VariadicParameter           ::=  Type '...' Identifier
        
        Note: it is not included in the grammar, but it is illegal to have a parameter without a default value after
        a parameter that does.

        Creates a node with 5 children
            - ParameterTypes - List of ASTNodes containing the type of each of the parameters. If parsing inferred
              types, this list will always be empty
            - ParameterNames - List of CodeObjects containing the names of each of the parameters
            - DefaultValues - List of ASTNodes containing Expressions, which are the defualt values of the parameters.
              When some parameters don't have default values, the values in this list correspond to the parameters at 
              the end of the parameter lists (not including the variadic parameter)
            - VariadicName - CodeObject containing the name of the variadic parameter, or None if there is no variadic
              parameter
            - VariadicType - ASTNode containing a Type, which is the type of the variadic parameter, or None if there
              is no variadic parameter

        Args:
            inferred (bool): If True parses inferred type parameters, otherwise parses explicit type parameters.
                Defaults to False, meaning explicit type parameters are parsed by default.
        Returns:
            ASTNode: The node generated by parsing the parameter list, or None if parsing failed
        """
        node = ASTNode("ParameterList", {'ParameterNames': [], 'ParameterTypes': [], 'DefaultValues': [],
                                         'VariadicName': None, 'VariadicType': None})
        variadic = False
        if not inferred:
            if not self.parse(self.type, node, 'ParameterTypes'):
                return None

            variadic = self.match('...')

        if not self.get_type() == Token.identifier:
            if not inferred:
                raise CompilerException(CompilerException.SYNTAX, "Expected parameter name after parameter type in "
                                                                  "function header", self.value(-1))
            else:
                return None

        node.addchild('VariadicName' if variadic else 'ParameterNames', self.value())
        if variadic:
            node.addchild('VariadicType', node['ParameterTypes'][-1])
            node['ParameterTypes'].pop()
        self.index += 1
        if self.match('='):
            if variadic:
                raise CompilerException(CompilerException.SYNTAX,
                                        "Cannot have default values for variadic parameters", self.value(-1))
            if not self.parse(self.variable_initializer, node, 'DefaultValues'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected expression after '=' in function parameter", self.value(-1))

        while self.match(','):
            if variadic:
                raise CompilerException(CompilerException.SYNTAX,
                                        "Variadic parameter must be the last parameter in a function", self.value(-1))
            if not inferred:
                if not self.parse(self.type, node, 'ParameterTypes'):
                    raise CompilerException(CompilerException.SYNTAX, "Expected function parameter type after comma in "
                                                                      "function declaration", self.value(-1))
                variadic = self.match('...')

            if not self.get_type() == Token.identifier:
                if inferred:
                    raise CompilerException(CompilerException.SYNTAX,
                                            "Expected parameter name after comma in function header", self.value(-1))
                else:
                    raise CompilerException(CompilerException.SYNTAX, "Expected parameter name after parameter type in "
                                                                      "function header", self.value(-1))
            node.addchild('VariadicName' if variadic else 'ParameterNames', self.value())
            if variadic:
                node.addchild('VariadicType', node['ParameterTypes'][-1])
                node['ParameterTypes'].pop()
            self.index += 1
            if self.match('='):
                if variadic:
                    raise CompilerException(CompilerException.SYNTAX,
                                            "Cannot have default values for variadic parameters", self.value(-1))
                if not self.parse(self.variable_initializer, node, 'DefaultValues'):
                    raise CompilerException(CompilerException.SYNTAX,
                                            "Expected expression after '=' in function parameter", self.value(-1))
            elif len(node['DefaultValues']) > 0 and not variadic:
                raise CompilerException(CompilerException.SYNTAX, "Cannot have positional parameters after "
                                                                  "parameters with a default value", self.value(-1))

        return node

    def constructor_declaration(self):
        """
        Parses a constructor declaration. A constructor declaration is very similar to a function declaration, except it
        cannot be static, it has no return type, and its name must be 'constructor'. Also, in the constructor body, two
        new statements are allowed, one of which can occur as the fist statement in the body, which are parsed under
        the name ConstructorInvocation

        | **ConstructorDeclaration**   ::=  ConstructorHeader ConstructorBody
        | **ConstructorHeader**        ::=  PrivacyModifier? 'constructor' '(' ParameterList? ')'
        | **PrivacyModifier**          ::=  'private' | 'public'
        | **ParameterList**            ::=  Type Identifier (',' Type Identifier)*
        | **FunctionBody**               ::=  '{' ConstructorInvocation Statement* '}'

        A function declaration has the following children
            - PrivacyModifier - A CodeObject. May be None
            - ParameterNames - List of CodeObjects, each of which is the identifier if one of the function parameters
            - ParameterTypes - List of ASTNodes, each of which is a Type, that is the type of each of the function
              parameters. These are in the same order as the parameters in ParameterNames.
            - ConstructorInvocation - ASTNode containing a ConstructorInvocation. May be None
            - Statements - List of ASTNodes, each of which is a Statement

        Returns:
            ASTNode: The node generated by parsing the constructor declaration, or None if parsing failed
        """
        node = ASTNode('ConstructorDeclaration', {'Statements': [], 'ParameterList': None})
        self.add_optional(node, ['private', 'public', 'protected'], 'PrivacyModifier')

        if not self.match('constructor'):
            return None

        if not self.match('('):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected opening bracket, '(', after function name", self.value(-1))

        self.parse(self.parameter_list, node, 'ParameterList')

        if not self.match(')'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected closing bracket, ')', after function arguments", self.value(-1))

        if not self.match('{'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected opening brace, '{', after function header", self.value(-1))

        if not self.parse(self.constructor_invocation, node, 'ConstructorInvocation'):
            node.addchild('ConstructorInvocation', None)
        while self.parse(self.statement, node, 'Statements'):
            pass

        if not self.match('}'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected closing bracket, '}', after function body", self.value(-1))

        return node

    def field_declaration(self):
        """
        Parses a field declaration. A field declaration declares a variable that belongs to a class.

        | **FieldDeclaration**      ::=  PrivacyModifier 'static'? Type VariableDeclarator (',' VariableDeclarator)* ';'
        | **VariableDeclarator**    ::=  Identifier ('=' VariableInitializer)?

        Creates a node with the following children
            - PrivacyModifier - CodeObject that may be None
            - Static - A CodeObject. May be None
            - Type - ASTNode object containing a Type
            - Names - A list of CodeObjects containing the name of each field
            - VariableInitializers - A list of ASTNodes containing either ArrayInitializer or Expression nodes.
              If an initializer is omitted then the relevant entry in this list will be None

        Returns:
            ASTNode: The node generated by parsing the constructor declaration, or None if parsing failed
        """
        node = ASTNode('FieldDeclaration', {'Names': [], 'VariableInitializers': []})
        self.add_optional(node, ['private', 'public', 'protected'], 'PrivacyModifier')
        self.add_optional(node, ['static'], 'Static')

        if not self.parse(self.type, node, 'Type'):
            return None

        if not self.get_type() == Token.identifier:
            raise CompilerException(CompilerException.SYNTAX, "Expected variable identifier in field declaration",
                                    self.value(-1))
        node.addchild('Names', self.value())
        self.index += 1

        if self.match('='):
            if not self.parse(self.variable_initializer, node, 'VariableInitializers'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected variable initializer after '=' in field declaration", self.value(-1))
        else:
            node.addchild('VariableInitializers', None)

        while self.match(','):
            if not self.get_type() == Token.identifier:
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected variable identifier after ',' in field declaration",
                                        self.value(-1))
            node.addchild('Names', self.value())
            self.index += 1

            if self.match('='):
                if not self.parse(self.variable_initializer, node, 'VariableInitializers'):
                    raise CompilerException(CompilerException.SYNTAX,
                                            "Expected variable initializer after '=' in field declaration",
                                            self.value(-1))
            else:
                node.addchild('VariableInitializers', None)

        if not self.match(';'):
            raise CompilerException(CompilerException.SYNTAX, "Expected ';' after field declaration", self.value(-1))

        return node

    def variable_initializer(self):
        """
        Variable initializer is any expression that can be used during variable creation. It is any normal expression,
        an array initializer or an anonymous function. The reason array initializers and anonymous functions are not
        included in expressions is because their type is not always able to be determined. Thus, we put them in a
        seperate construction so we can ensure they are only used in places where their type can be inferred. This
        includes variable assignment and initializers, and arguments for functions.

        | **VariableInitializer**   ::= ArrayInitializer | AnonymousFunction | Expression

        Note: this does not generate its own node. Instead it returns the node created by the
        ArrayInitializer/AnonymousFunction/Expression parsing

        Returns:
            ASTNode: The node generated by parsing the variable initializer, or None if parsing failed
        """
        node = ASTNode('VariableInitializer')
        if self.parse(self.array_initializer, node, 'ArrayInitializer'):
            return node['ArrayInitializer']
        if self.parse(self.anonymous_function, node, 'AnonymousFunction'):
            return node['AnonymousFunction']
        if self.parse(self.expression, node, 'Expression'):
            return node['Expression']
        return None

    def array_initializer(self):
        """
        Parses an array initializer which is used to create an array when first initializing a variable

        ArrayInitializer    ::=  '{' (VariableInitializer (',' VariableInitializer)*)? '}'

        Creates a node with a single child
            - VariableInitializers - A list of ASTNode containing either ArrayInitializers or Expressions

        Returns:
            ASTNode: The node generated by parsing the array initializer, or None if parsing failed
        """
        node = ASTNode('ArrayInitializer', {'VariableInitializers': []})
        if not self.match('{'):
            return None
        self.parse(self.variable_initializer, node, 'VariableInitializers')
        while self.match(','):
            if not self.parse(self.variable_initializer, node, 'VariableInitializers'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected value after comma in array initializer", self.value(-1))

        if not self.match('}'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected closing brace, '}', after array initializer", self.value(-1))
        return node

    def constructor_invocation(self):
        """
        Parses a constructor invocation. A constructor invocation calls another constructor in the same class, or in a
        super class.

        | **ConstructorInvocation**     ::=  ('this' | 'super')
                                             '(' (VariableInitializer (',' VariableInitializer)*)? ')' ';'

        Creates a node with 2 children
            - Kind - CodeObject that contains either 'this' or 'super'
            - Arguments - List of ASTNodes, each of which is an Expression

        Returns:
            ASTNode: The node generated by parsing the constructor invocation, or None if parsing failed
        """
        node = ASTNode('ConstructorInvocation', {'Arguments': []})
        if not self.add_optional(node, ['this', 'super'], 'Kind'):
            return None
        if not self.match('('):
            return None

        self.parse(self.variable_initializer, node, 'Arguments')
        while self.match(','):
            if not self.parse(self.variable_initializer, node, 'Arguments'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected argument value after comma in constructor call", self.value(-1))

        if not self.match(')'):
            raise CompilerException(CompilerException.SYNTAX, "Expected closing bracket, ')' after argument list in "
                                                              "constructor call", self.value(-1))

        if not self.match(';'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected semicolon, ';', after constructor call", self.value(-1))

        return node

    def anonymous_function(self):
        """
        Parses an anonymous function, defined as follows

        | **AnonymousFunction**     ::=  LambdaParameters '->' LambdaBody
        | **LambdaParameters**      ::=  ('(' ParameterList? ')') | ('(' InferredParameterList? ')') | Identifier
        | **LambdaBody**            ::=  Expression | ('{' Statement* '}')

        Creates a node with 3 children
            - Parameters - ASTNode or CodeObject. If it is a node, it is a ParameterList containing the function
              parameters. If it is a CodeObject, it is an identifier of the single parameter. May also be None if there
              are no parameters
            - Expression - If a single expression is used as the body, then this contains the Expression ASTNode.
              Otherwise, this will be None
            - Statements - If a block is used as the function body, then this contains a list of ASTNodes containing
              Statement nodes. This is never None, so you must check if Expression is None or not, to determine if a
              code block was used

        Returns:
            ASTNode: The node generated by parsing the anonymous function, or None if parsing failed
        """
        node = ASTNode('AnonymousFunction', {'Expression': None, 'Statements': [], 'Parameters': None})
        if self.get_type() == Token.identifier:
            node.addchild('Parameters', self.value())
            self.index += 1
            if not self.match('->'):
                return None
        else:
            if not self.match('('):
                return None

            # Parameter list parsing can raise errors if the list is has inferred types, so we must catch the errors
            try:
                success = self.parse(self.parameter_list, node, 'Parameters')
            except CompilerException:
                success = False

            if not success:
                self.parse(lambda: self.parameter_list(inferred=True), node, 'Parameters')
            # At this stage, we can potentially have an identifier in brackets which is a legal expression, so we cannot
            # raise errors here
            if not self.match(')'):
                return None

            if not self.match('->'):
                return None

        if self.parse(self.expression, node, 'Expression'):
            return node

        if not self.match('{'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected opening brace, '{', after function header", self.value(-1))

        while self.parse(self.statement, node, 'Statements'):
            pass

        if not self.match('}'):
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected closing brace, '}', after function body", self.value(-1))

        return node

    def expression(self):
        """
        Parses an expression.
        :return:
        """
        node = ASTNode('Expression')
        if self.parse(self.primary, node, 'Primary'):
            return node
        return None

    def primary(self):
        """
        Parses a primary expression, which is the simplest form of an expression.

        | **Primary**  ::=  Literal | 'this' | FunctionInvocation | ClassCreation | ArrayCreation
                          | FieldAccess | ('(' Expression ')')

        The name of the node created indicates which type of primary was created. The name of the child will be the same
        as the name of the node

        Returns:
            ASTNode: The node generated by parsing the primary expression, or None if parsing failed
        """
        node = ASTNode('')
        if self.match('this'):
            node.name = 'This'
            node.addchild('This', self.value(-1))
            return node

        if self.match('true') or self.match('false'):
            node.name = 'BoolLiteral'
            node.addchild('BoolLiteral', self.value(-1))
            return node

        if self.match('null'):
            node.name = 'NullLiteral'
            node.addchild('NullLiteral', self.value(-1))
            return node

        if self.get_type() == Token.string:
            node.name = 'StringLiteral'
            node.addchild('StringLiteral', self.value())
            self.index += 1
            return node

        if self.get_type() == Token.character:
            node.name = 'CharacterLiteral'
            node.addchild('CharacterLiteral', self.value())
            self.index += 1
            return node

        if self.get_type() == Token.integer:
            node.name = 'IntegerLiteral'
            node.addchild('IntegerLiteral', self.value())
            self.index += 1
            return node

        if self.get_type() == Token.float:
            node.name = 'FloatLiteral'
            node.addchild('FloatLiteral', self.value())
            self.index += 1
            return node

        if self.parse(self.array_creation, node, 'ArrayCreation'):
            node.name = 'ArrayCreation'
            return node

        if self.parse(self.class_instance_creation, node, 'ClassInstanceCreation'):
            node.name = 'ClassInstanceCreation'
            return node

        if self.parse(self.function_invocation, node, 'FunctionInvocation'):
            node.name = 'FunctionInvocation'
            return node

        if self.parse(self.field_access, node, 'FunctionInvocation'):
            node.name = 'FunctionInvocation'
            return node

        return None

    def array_initialization(self):
        """
        Parses an array initialization. An array initialization creates an array, but does not set any of the values

        | **ArrayInitialization**       ::=  ('new' NonFunctionArrayType DimExpressions Dims)
        | **DimExpressions**            ::=  ('[' Expression ']')+
        | **Dims**                      ::=  ('[' ']')*

        Returns:
            ASTNode: The node generated by parsing the array initialization, or None if parsing failed
        """
        # The node is called ArrayCreation becuase it is passed up to the array creation function, which uses the
        # node directly as its own node.
        node = ASTNode('ArrayCreation', {'DimExpressions': [], 'Dims': []})
        if not self.match('new'):
            return None
        if not self.parse(self.non_function_array_type, node, 'Type'):
            raise CompilerException(CompilerException.SYNTAX, "Expected type after 'new' keyword", self.value(-1))
        # At this stage could still be a class creation
        if not self.match('['):
            return None
        if not self.parse(self.expression, node, 'DimExpressions'):
            return None
        if not self.match(']'):
            raise CompilerException(CompilerException.SYNTAX, "Expected closing square bracket, ']' after array "
                                                              "dimension", self.value(-1))

        finished = False
        while not finished and self.match('['):
            if not self.parse(self.expression, node, 'DimExpressions'):
                node.addchild('Dims', self.value(-1))
                finished = True
            if not self.match(']'):
                raise CompilerException(CompilerException.SYNTAX, "Expected closing square bracket, ']' after array "
                                                                  "dimension", self.value(-1))
        if finished:
            node.addchild('Dims', self.value(-1))

        while self.match('['):
            node.addchild('Dims', self.value(-1))
            if not self.match(']'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Unmatched bracket. Expected closing square bracket, '[', after the opening "
                                        "square bracket, ']', in array type", self.value(-1))
            node.addchild('Dims', self.value(-1))

        return node

    def array_creation(self):
        """
        Parses an array creation expression. Arrays can be created with reference types, primitive types and function
        types, but not array types (because it is itself an array). Thus, it is defined as

        | **ArrayCreationExpression**   ::=  ArrayInitialization | ('new' NonFunctionType ArrayInitializer)

        Creates a node with the following children
            - Type - ASTNode containing the type of the array
            - DimExpressions - If an array initialization was parsed, this is a list of ASTNodes, containing the
              expressions defining the dimensions of the array (does not exist if an ArrayInitialization is not parsed)
            - Dims - If an array initialization was parsed, this is a list of CodeObjects containing any square brackets
              without dimension values (does not exist if an ArrayInitialization is not parsed. In this case, any Dims
              are contained within the Type node)
            - ArrayInitializer - ASTNode containing an ArrayInitializer node (does not exist if an ArrayInitialization
              is parsed)

        Returns:
            ASTNode: The node generated by parsing the array creation expression, or None if parsing failed
        """
        node = ASTNode('ArrayCreation')
        if self.parse(self.array_initialization, node, 'ArrayInitializer'):
            return node['ArrayInitializer']

        if not self.match('new'):
            return None

        if not self.parse(self.non_function_type, node, 'Type'):
            raise CompilerException(CompilerException.SYNTAX, "Expected type after 'new' keyword", self.value(-1))

        if len(node['Type']['Dims']) < 2:
            return None     # Not an array. Possibly a class creation, so don't raise error

        if not self.parse(self.array_initializer, node, 'ArrayInitializer'):
            # This will always point to the first square bracket in the array initializer
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected either array dimensions or an array initializer",
                                    self.value(-len(node['Type']['Dims'])))
        return node

    def class_instance_creation(self):
        """
        Parses a class instance creation expression.

        | **ClassInstanceCreation**     ::=  'new' ReferenceType
                                             '(' (VariableInitializer (',' VariableInitializer)*)? ')'
        Creates a node with 2 children
            - Type - A ReferenceType ASTNode containing the class to create an instance of
            - Arguments - A list of VariableInitializer ASTNodes, containing the arguments for the constructor of the
              class

        Returns:
            ASTNode: The node generated by parsing the class instance creation, or None if parsing failed
        """
        node = ASTNode('ClassInstanceCreation', {'Arguments': []})
        if not self.match('new'):
            return None

        if not self.parse(self.reference_type, node, 'Type'):
            raise CompilerException(CompilerException.SYNTAX, "Expected type after 'new' keyword", self.value(-1))

        if not self.match('('):
            raise CompilerException(CompilerException.SYNTAX, "Expected opening bracket, '(', for argument list, after "
                                                              "class intance creation", self.value(-1))

        self.parse(self.variable_initializer, node, 'Arguments')
        while self.match(','):
            if not self.parse(self.variable_initializer, node, 'Arguments'):
                raise CompilerException(CompilerException.SYNTAX, "Expected argument value after comma in class "
                                                                  "instance creation", self.value(-1))

        if not self.match(')'):
            raise CompilerException(CompilerException.SYNTAX, "Expected closing bracket, ')' after argument list in "
                                                              "class instance creation", self.value(-1))
        return node

    def function_invocation(self):
        """
        Parses a function invocation (function call).

        | **FunctionInvocation**    ::=  FieldAccess Generics? '(' (VariableInitializer (',' VariableInitializer)*)? ')'
        | **FunctionName**          ::=  (Primary '.' Identifier) | ('super' '.' Identifier) | TypeName

        Creates a node with 2 children
            - Generics - A Generics ASTNode
            - Arguments - A list of VariableInitializer ASTNodes, containing the arguments for the constructor of the
              class
            - Name - If FunctionName is parsed under one of the first two constructions, then this is a CodeObject
              containing the name of the function. Otherwise, this is a TypeName node
            - TargetObject - If FunctionName is parsed under the first construction, then this is a Primary ASTNode, if
              it is parsed under the second construction, this contains a CodeObject containing 'super', otherwise this
              is None

        Returns:
            ASTNode: The node generated by parsing the function invocation, or None if parsing failed
        """
        # We can't raise errors until we parse the first bracket, because it may just be a field access
        node = ASTNode('FunctionInvocation', {'Arguments': [], 'TargetObject': None})
        if self.match('super'):
            node.addchild('TargetObject', self.value(-1))
        elif self.parse(self.primary, node, 'TargetObject'):
            if not self.match('.'):
                return None

        return None

    def field_access(self):
        return None

    def array_access(self):
        return None

    def statement(self):
        return None

    def add_optional(self, node, tokens, name):
        """
        Checks if the current token is a one of the strings provided in the tokens argument. If it is, then the
        token is added to the given node under the name given. Otherwise, None is added under that name

        Args:
            node (ASTNode): The node to add the token to
            tokens (list<str>): List of strings representing the possible tokens to match against
            name (str): The name to give to the child that is added to node

        Returns:
            bool: True if one of the tokens matched the current token, False otherwise
        """
        for token in tokens:
            if self.match(token):
                node.addchild(name, self.value(-1))
                return True

        node.addchild(name, None)
        return False

    def type(self):
        """
        Parses a type. A type covers any type a variable can be, including primitives, classes, arrays,
        functions and generic types

        | **Type**      ::=  FunctionType | NonFunctionType

        The name of the node returned indicates what the type is. It will be one of PrimitiveType, ReferenceType or
        FunctionType. Each one has two children. The first is the type, whose name matches the name of the node. For
        PrimitiveType, this is a CodeObject, otherwise it is an ASTNode. The second child is a list of CodeObjects,
        named Dims, which contains all the square brackets. The number of dimensions of the array is half the length of
        this list

        Note: If a NonFunctionType is parsed, then this function returns exactly the node generated by that, rather
        than packing it in a Type node as is typically done.

        Returns:
            ASTNode: The node generated by parsing the type, or None if parsing failed
        """
        func_node = ASTNode('FunctionType')
        if self.parse(self.function_type, func_node, 'FunctionType'):
            return func_node
        if self.parse(self.non_function_type, func_node, 'NonFunctionType'):
            return func_node['NonFunctionType']
        return None

    def non_function_type(self):
        """
        Parses any type that is not a function type. This includes class and generic types (ReferenceType), primitives,
        arrays of reference and primitive types and also arrays of functions (but not functions on their own)

        | **NonFunctionType**   ::=  NonFunctionArrayType Dims
        | **Dims**              ::=  ('[' ']')*

        The name of the node returned indicates what the type is. It will be one of PrimitiveType, ReferenceType or
        FunctionType. Each one has two children. The first is the type, whose name matches the name of the node. For
        PrimitiveType, this is a CodeObject, otherwise it is an ASTNode. The second child is a list of CodeObjects,
        named Dims, which contains all the square brackets. The number of dimensions of the array is half the length of
        this list

        Returns:
            ASTNode: The node generated by parsing the non function type, or None if parsing failed
        """
        node = ASTNode('', {'Dims': []})
        if not self.parse(self.non_function_array_type, node, 'Type'):
            return None

        # Unwrap the generated node, to simplify the tree
        node.name = node['Type'].name
        node[node.name] = node['Type'][node.name]
        del node.children['Type']

        while self.match('['):
            node.addchild('Dims', self.value(-1))
            if not self.match(']'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Unmatched bracket. Expected closing square bracket, '[', after the opening "
                                        "square bracket, ']', in array type", self.value(-1))
            node.addchild('Dims', self.value(-1))

        return node

    def non_function_array_type(self):
        """
        Parses a type that is not a function or array. This is necessary as the type in an array creation expression
        cannot itself be an array, and function types must be inside brackets (raw function type is ambigous)

        | **NonFunctionArrayType**      ::=  ReferenceType | PrimitiveType | ('(' FunctionType ')')
        | **PrimitiveType**             ::=  'byte' | 'char' | 'bool'

        Note: this does not create its own node, instead it simply returns the node generated by parsing one of the
            sub types

        Returns:
            ASTNode: The node generated by parsing the non function array type, or None if parsing failed
        """
        node = ASTNode('')
        start = self.index
        if self.match('('):
            if not self.parse(self.function_type, node, 'FunctionType'):
                return None
            if not self.match(')'):
                raise CompilerException(CompilerException.SYNTAX, "Unmatched bracket. Expected closing bracket after "
                                                                  "function type definition", self.tokens[start][1])
            node.name = 'FunctionType'
            return node

        if self.parse(self.reference_type, node, 'ReferenceType'):
            node.name = 'ReferenceType'
            return node

        if self.match('byte') or self.match('char') or self.match('bool'):
            node.name = 'PrimitiveType'
            node.addchild('PrimitiveType', self.value(-1))
            return node

        return None

    def reference_type(self):
        """
        Parses a reference type. A reference type is any type that is the name of a class/interface, optionally followed
        by generic type arguments. It may also be a generic name identifier
        | **ReferenceType**     ::=  TypeName ('<' Type (',' Type)* '>')?

        Creates an ASTNode with the following children
            - TypeName - ASTNode that is a TypeName
            - TypeArguments - List of ASTNodes of type Type

        Returns:
            ASTNode: The node generated by parsing the reference type, or None if parsing failed
        """
        node = ASTNode('ReferenceType', {'TypeArguments': []})
        if not self.parse(self.type_name, node, 'TypeName'):
            return None

        if self.match('<'):
            if not self.parse(self.type, node, 'TypeArguments'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Expected type argument after angle bracket, '<'", self.value(-1))

            while self.match(','):
                if not self.parse(self.type, node, 'TypeArguments'):
                    raise CompilerException(CompilerException.SYNTAX, "Expected more type arguments after ','",
                                            self.value(-1))

            if not self.match('>'):
                raise CompilerException(CompilerException.SYNTAX,
                                        "Type arguments not closed. Expected '>' after type arguments", self.value(-1))

        return node

    def function_type(self):
        """
        A function type is defined as

        | **FunctionType**    ::=  ('(' TypeList? ')' '->' (Type | 'void'))
                                 | (NonFunctionType '->' (Type | 'void'))
        | **TypeList**        ::=  Type (',' Type)*

        If brackets aren't used for the arguments, then the argument must be a non function type, otherwise, we would
        get an error since type would call function, which would then immediatly call type, resulting in an infitite
        loop

        Creates a node with the following children
            - ArgumentTypes - Array of ASTNodes, each one of which is a Type
            - ReturnType - Either a CodeObject containing 'void' or an ASTNode which is a Type

        Returns:
            ASTNode: The node generated by parsing the function type, or None if parsing failed
        """
        node = ASTNode('FunctionType', {'ArgumentTypes': []})

        if not self.parse(self.non_function_type, node, 'ArgumentTypes'):
            if not self.match('('):
                return None
            self.parse(self.type, node, 'ArgumentTypes')
            while self.match(','):
                self.parse(self.type, node, 'ArgumentTypes')
            if not self.match(')'):
                self.raise_error(CompilerException.SYNTAX,
                                 "Unexpected Token. Expected closing bracket, ')' after function argument type list",
                                 missing_msg="Expected closing bracket, ')' after function argument type list")

        if not self.match('->'):
            return None
        if self.match('void'):
            node.addchild('ReturnType', self.value(-1))
            return node
        if self.parse(self.type, node, 'ReturnType'):
            return node
        self.raise_error(CompilerException.SYNTAX,
                         'Unexpected Token. Expected return type for function type declaration',
                         missing_msg='Expected return type for function type declaration')
        return node

    def type_name(self):
        """
        Parses a type name. A type name is a sequence of identifiers, seperated with dots:
        **TypeName**        ::=  (Identifier '.')* Identifier

        Creates a node with a single child:
            - Names - List of CodeObjects where each one is an identifier in the sequence of names

        Returns:
            ASTNode: The node generated by parsing the type name, or None if parsing failed
        """
        if self.get_type() is not Token.identifier:
            return None

        node = ASTNode('TypeName', {'Names': [self.value()]})
        self.index += 1
        while self.match('.'):
            if self.get_type() is Token.identifier:
                node.addchild('Names', self.value())
                self.index += 1
            else:
                raise CompilerException(CompilerException.SYNTAX,
                                        'Missing identifier after dot in type name', self.value(-1))

        return node


class ASTNode:
    """
    Represents a single node in an abstract syntax tree. Each node has a name (e.g. class declaration) and a dictionary
    of its children. Each child is an ASTNode. The keys of the children dictionary are the names of each child node,
    and the values are can be one of three things:

    - A token generated in the tokenizer. This is when the child is a terminal value (has no children of it own). A
      token is a tuple, consisting of the type (str) and the value (CodeObject)
    - An ASTNode. This is used when the child has its own children
    - A list of ASTNode objects or tokens. The list must consist of one or the other (not both). This is used when it is
      not known how many children of a certain type a node will have. For example, a parameter list will have an
      arbitrary number of ASTNode children, one for each parameter
    For example, a class declaration node may have the following children:
        'PrivacyModifier', 'Name', 'FieldDeclarations', 'FunctionDeclarations'
    where 'PrivacyModifier' and 'Name' both consist of a token, and 'FieldDeclarations',
    'FunctionDeclarations' would both be lists of ASTNodes, since we cannot know how many variables/functions a class
    will have

    Attributes:
        name (str): the name/type of the ASTNode
        children (dict) dictionary containing all the children of the node
    """

    def __init__(self, name, children=None):
        self.name = name
        if children is None:
            self.children = {}
        else:
            self.children = children

    def addchild(self, name, child):
        """
        Adds the child to the children dictionary at the location given by name. If multiple children are added to the
        same name, then they will all be stored in a list. If a given item must be a list, even if it may have zero or
        one elements, then add an emtpy list before adding any children under that name
        """
        if name in self.children:
            if type(self[name]) is list:
                self[name].append(child)
            elif self[name] is None:
                self[name] = child
            else:
                self[name] = [self[name], child]
        else:
            self[name] = child

    def __setitem__(self, name, child):
        """
        Sets the child with the given name to the given value.
        Note: This will overwrite any child already existing under that name. To add a child without the risk of
        overwriting a child use addchild(name, child)
        """
        self.children[name] = child

    def __getitem__(self, item):
        """This is used to access the children of the ASTNode"""
        return self.children[item]

    def print_tree(self, depth=0):
        """
        Prints this node, along will all child nodes, in a heirarcical manner
        Args:
            depth: This is the depth of this node from the root of the tree. This determines how far to indent this
                node
        """
        if depth == 0:
            print(self.name)
        prefix = '|   ' * depth + '|-> '
        for name, child in self.children.items():

            if type(child) is list:
                if len(child) == 0:
                    continue

                list_type = 'terminal'
                for item in child:
                    if type(item) is ASTNode:
                        list_type = 'non terminal'
                        break

                if list_type == 'non terminal':
                    print(prefix + name)
                    for i in range(len(child)):
                        if child[i] is None:
                            print('|   ' + prefix + str(i) + ' (None)')
                        else:
                            print('|   ' + prefix + str(i) + ' (' + child[i].name + ')')
                            child[i].print_tree(depth + 2)
                else:
                    print(prefix + name + ": " + str(child))
            elif type(child) is ASTNode:
                print(prefix + name + ' (' + child.name + ')')
                child.print_tree(depth + 1)
            else:
                print(prefix + name + ": " + str(child))
