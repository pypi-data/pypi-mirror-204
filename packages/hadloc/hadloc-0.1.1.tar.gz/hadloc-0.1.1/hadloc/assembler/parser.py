from hadloc.assembler.tokenizer import Token, TokenType
from hadloc.error import CompilerException, ExceptionType
from hadloc.text_utils import CodeObject, PositionedString, add


class Parser:
    """
    The parser interprets each line of tokens, and converts them into instructions. The parser will evaluate all
    definitions, and replace any instances of them with their value

    The parser will convert lda and ldb pseudo instructions with literal or defined values into the corresponding
    assembly instructions. However, if a label is used as an argument for a load instruction, it will be left as a
    label, as the values of the labels are determined in the label_encoder. After the label_encoder resolves the
    line numbers, these will be converted into assembly instructions

    The parser will also create a dictionary of all the labels present in the code. The dictionary uses
    the label as a key, and the line number as the value. Note that this line number may change in the label_encoder
    stage, because not all pseudo instructions are evaluated at this stage. It will also check that no labels are used
    that are not defined in the code

    The final function performed by the parser is to validate the code. If the code has any errors they will be caught
    here, and a CompilerException will be raised. All errors are caught here, so no error checking is required in
    later stages. It also means later stages no longer need a reference to the source code, so the returned instructions
    are raw strings and ints, not PositionedStrings or CodeObjects. Furthermore, the parser will generate a list of
    warnings. Warnings are generated in the following situations
        - A label or definition is defined but not used, so it could be safely deleted from the source code
        - A move instruction is used with the same source and destination. This has no effect so could be removed or
            replaced with a nop. The Parser will replace this with a nop

    Args:
        tokens: A list containing the tokens generated from the source code of an assembly file. This should be
            created using tokenizer.tokenize(text)

    Attributes:
        tokens: Stores the tokens passed in as an argument
        index: The index within the current line of the current token being parsed
        labels: A dictionary containing the labels as keys, and the line number of the label as the value. The line
            number is the line number of the instructions generated from parsing (not the final line number)
        definitions: A dictionary containing the names of the definitions as keys, and the values of the definitions as
            the value. Unlike the labels' dictionary, these values are final.
        instructions: List of instructions, where each instruction is a list of strings or ints. These instructions are
            guaranteed to be valid, so no error checking is required
        used_labels: List of the labels used in the code. These are the labels that are used in load instructions, NOT
            the labels that are created. If there is a label in this list, that is not in the labels' dictionary, then
            there is a CompilerException, as an undefined label was used. Conversely, if there is a label that is not
            in this list, then a warning is created as there is an unused label
        used_definitions: Serves an identical purpose to used_labels, but for definitions
        warnings: List of warnings generated by the parser. Warnings are issues with the code that do not prevent
            assembly. Warnings are given if there are definitions or labels that are unused

    Raises:
        CompilerException: If there are any errors with the code
    """
    def __init__(self, tokens: list[Token]):
        self.tokens = tokens
        self.index = 0
        self.labels: dict[CodeObject, int] = {}
        self.definitions: dict[CodeObject, int] = {}
        self.instructions: list[list[str | int]] = []
        self.used_labels: set[CodeObject] = set()
        self.used_definitions: set[CodeObject] = set()
        self.warnings: list[str] = []

    def run(self) -> tuple[list[list[str | int]], list[str], dict[str, int]]:
        """
        Parses the tokens into a list of valid instructions

        Returns: (instructions, warnings, labels)
            labels: A dictionary containing the labels as keys, and the line number of the label as the value. The
                line number is the line number of the instructions generated from parsing (not the final line number)
            instructions: List of instructions, where each instruction is a list of strings or ints. These
                instructions are guaranteed to be valid, so no further error checking is required
            warnings: List of warnings generated by the parser. Warnings are issues with the code that do not prevent
                assembly. Warnings are given if there are definitions or labels that are unused

        Raises:
            CompilerException:
                - If there are any errors within the code
        """
        self.instructions.append(['nop'])
        self.instructions.append(['nop'])
        self.parse_program()
        self.instructions.append(['hlt'])

        # Check that all labels are defined. Don't need this for definitions as they must be defined before they are
        # used, so they are caught during parsing
        for label in self.used_labels:
            if label.value not in self.labels:
                raise CompilerException(ExceptionType.NAME, label, f"The identifier '{label}' has not been defined")

        # Check if there are any labels or definitions that weren't used
        for label in self.labels:
            if label.value not in self.used_labels:
                self.warnings.append(f"The label '{label}' on line {label.line() + 1} was never used")

        for definition in self.definitions:
            if definition.value not in self.used_definitions:
                self.warnings.append(f"The constant '{definition}' on line {definition.line() + 1} was never used")

        labels = {label.value: value for label, value in self.labels.items()}
        return self.instructions, self.warnings, labels

    def token(self, offset: int = 0) -> Token | None:
        """
        Returns the token offset by a given amount from the token currently being parsed. If the requested token is
        outside the range of the token list, an INSTRUCTION_END token is returned

        Args:
            offset: the offset from the current token

        Returns: the token offset by a given amount from the token currently being parsed, or an INSTRUCTION_END token
            if this is outside the range of the tokens list
        """
        return self.tokens[self.index + offset] \
            if self.index + offset < len(self.tokens) \
            else Token(TokenType.INSTRUCTION_END)

    def end_instruction(self, required: bool = False):
        """
        Advances over an INSTRUCTION_END token if it is then next token. The required parameter indicates if it is
        required to end the instruction or optional. If required is true, then an exception is raised if the next token
        is not an INSTRUCTION_END. If required is False, then nothing happens if it is not an INSTRUCTION_END

        Args:
            required: whether it is required to end the instruction
        """
        if self.token().token_type is TokenType.INSTRUCTION_END:
            self.index += 1
        elif required:
            raise CompilerException(ExceptionType.SYNTAX, self.token(), 'Unexpected Token')

    def add_instruction(self, instruction: list[PositionedString | str | int | None]):
        """
        Adds an instruction to the list of instructions. The input instruction can be a list of Token, strings or
        integers, and any tokens will be converted to their int or string value. None values can also appear in the
        instruction list, and they will be ignored (will not appear in the output). add_instruction also includes a call
        to end_instruction, as all instructions must end with an END_INSTRUCTION token

        Args:
            instruction: List of Token, string or int representing the instruction
        """
        raw_instruction: list[str | int] = []
        for token in instruction:
            if token is None:
                continue
            elif isinstance(token, Token):
                raw_instruction.append(token.value)
            else:
                raw_instruction.append(token)
        self.instructions.append(raw_instruction)
        self.end_instruction(required=True)

    def match(self, *matches: str | TokenType) -> Token | None:
        """
        Advances over the current token only if matches one of the arguments. If a token is advanced past, the
        token is returned, otherwise None is returned
        Args:
            *matches: values to match against the current token. Can be string (match against token value) or TokenType
                (match against token type)

        Returns: The token advanced over, or None if no token was matched
        """
        for match in matches:
            if self.token() == match:
                self.index += 1
                return self.token(-1)

    def parse_program(self):
        """
        Parses the entire list of tokens.
        Creates the labels dictionary and the used_labels list.
        Creates the instruction list and verifies the structure of the instructions are correct.
        See documentation for Parser for more information on what parsing a program achieves.

        Raises:
            CompilerException: If there is an error in the code
        """
        while self.index < len(self.tokens):
            if self.parse_definition():
                continue

            # Label and instruction can be on same line, so parse these together
            if self.parse_label() or self.parse_instruction():
                continue

            # If none of the above parsed successfully, there must be an error
            raise CompilerException(ExceptionType.SYNTAX, self.token(), 'Unexpected Token')

    def parse_label(self) -> bool:
        """
        Parses a label. A label consists of an identifier token, followed by a label token.
        If the label is successfully parsed, index is advanced past the label, and True is returned.
        The current line number is added to the labels dictionary with the key given by the value of the identifier
        token. No instructions are generated from parsing a label. If the label already exists in the labels dictionary
        a CompilerException is raised. If parsing is unsuccessful then False is returned and index is not changed.

        Returns: True if a label was parsed, False otherwise

        Raises:
            CompilerException: If parsing the label succeeds, but the identifier is defined elsewhere
        """
        if self.token().token_type is TokenType.IDENTIFIER and self.token(1).value == ':':
            if self.token().value in self.labels or self.token().value in self.definitions:
                raise CompilerException(ExceptionType.NAME, self.token(),
                                        f"The identifier '{self.token()}' has multiple definitions")

            self.labels[self.token()] = len(self.instructions)
            self.index += 2
            self.end_instruction()
            return True
        return False

    def parse_definition(self) -> bool:
        """
        Parses a definition. A definition is the keyword 'define' followed by an identifier, then an integer.

        Returns: True if a definition was parsed, False otherwise

        Raise:
            CompilerException: If parsing the definition succeeds, but the identifier is defined elsewhere
        """
        if not (self.token().token_type is TokenType.KEYWORD and self.token().value == 'define'):
            return False

        if not self.token(1).token_type is TokenType.IDENTIFIER:
            raise CompilerException(ExceptionType.ARG, self.token(1).value,
                                    "Expected identifier after a 'define' keyword")

        name = self.token(1)
        if name.value in self.labels or name.value in self.definitions:
            raise CompilerException(ExceptionType.NAME, name, f"The identifier '{name}' has multiple definitions")

        self.index += 2
        try:
            value = self.parse_constant_expression()
        except CompilerException as ce:
            ce.msg = ce.msg.format('define')
            raise ce

        if value is None:
            raise CompilerException(ExceptionType.SYNTAX, self.token().value,
                                    "Expected constant expression as argument to the 'define' instruction")

        if type(value.value) is str:
            raise CompilerException(
                ExceptionType.NAME, value,
                f"Invalid name, '{value}', used in expression. Constants must be defined before they are used, and "
                f"labels cannot be used in definitions"
            )

        self.end_instruction(required=True)
        self.definitions[name] = value.value
        return True

    def parse_instruction(self) -> bool:
        """
        Parses a single instruction. In this case an instruction refers to any line that produces machine code.
        Thus, this will parse everything except labels and definitions. Any tokens successfully parsed will be
        advanced over.

        Returns:
            True if an instruction was successfully parsed, False otherwise

        Raises:
            CompilerException:
                - The instruction is invalid in any way
        """
        if self.token().token_type is not TokenType.KEYWORD:
            return False

        return self.parse_no_argument_instruction() or self.parse_load_instruction() or \
            self.parse_move_instruction() or self.parse_output_instruction() or \
            self.parse_arithmetic_logic_instruction()

    def parse_no_argument_instruction(self) -> bool:
        """
        Parses any instruction that has no arguments
        Returns: True if an instruction was parsed
        """
        command = self.match('jmp', 'jgt', 'jeq', 'jlt', 'jge', ' jle', 'jne', 'jcs', 'jis', 'hlt', 'nop', 'ics', 'icc')
        if command is not None:
            self.add_instruction([command])
        return command is not None

    def parse_load_instruction(self) -> bool:
        """
        Parses the ldb, ldu and lda instructions. lda instructions are converted to

            ldu arg
            mov L H
            ldb arg

        'ldb' and 'ldu' instructions are compiled using the Parser.write_load() function.
        Returns: True if a command was parsed
        Raises:
            CompilerException:
                - If the instruction is a load instruction but the argument is not a valid expression
        """
        command = self.match('ldb', 'ldu', 'lda')
        if command is None:
            return False

        try:
            value = self.parse_constant_expression().value
        except CompilerException as ce:
            ce.msg = ce.msg.format(self.token())
            raise ce
        self.end_instruction(required=True)

        if command == 'lda':
            self.instructions += write_load('ldu', value)
            self.add_instruction(['mov', 'L', 'H'])
            self.instructions += write_load('ldb', value)
        else:
            self.instructions += write_load(command.value, value)
        return True

    def parse_move_instruction(self) -> bool:
        """
        Parses a move instruction. Generates a warning if source and destination are equal. This has no effect, so is
        replaced with a nop
        Returns: True if an instruction was parsed
        """
        if self.match('mov') is None:
            return False

        src, dst = self.verify_registers('mov', 2)
        if src == dst:
            self.warnings.append(
                f"Move command on line {src.line()} used with '{src}' as the source and destination register. "
                f"This has no effect and has been replaced with 'nop'"
            )
            self.add_instruction(['nop'])
            return True

        if dst == 'I':
            raise CompilerException(ExceptionType.ARG, dst,
                                    "Cannot move into the 'I' register. The 'I' register is read only")

        if src == 'H':
            raise CompilerException(ExceptionType.ARG, src,
                                    "Cannot move out of the 'H' register. The 'H' register write only")

        self.add_instruction(['mov', src, dst])
        return True

    def parse_output_instruction(self) -> bool:
        """
        Parses an output instruction
        Returns: True if an instruction was parsed
        """
        command = self.match('opd', 'opi')
        if command is None:
            return False

        src, = self.verify_registers(command, 1)
        if src in ['Y', 'H']:
            raise CompilerException(
                ExceptionType.ARG, src,
                f"The '{src}' register cannot be used as the argument to the '{command}' instruction"
            )

        self.add_instruction([command, src])
        return True

    def parse_arithmetic_logic_instruction(self) -> bool:
        """
        Parses an arithmetic or logic instruction
        Returns: True if an instruction was parsed
        """
        command = self.match('not', 'neg', 'inc', 'dec', 'sub', 'and', 'or', 'add')
        if command is None:
            return False

        if command in ['not', 'neg', 'inc', 'dec']:
            (dst, arg1), arg2 = self.verify_registers(command, 2), None
        else:
            dst, arg1, arg2 = self.verify_registers(command, 3)

        if dst not in ['X', 'L']:
            raise CompilerException(ExceptionType.ARG, dst,
                                    "The destination register of arithmetic and logic instructions must be 'X' or 'L'")

        for arg in [arg1, arg2]:
            if arg in ['I', 'Y', 'H']:
                raise CompilerException(
                    ExceptionType.ARG, arg,
                    f"The '{arg}' register cannot be used as an argument for the arithmetic and logic instructions"
                )

        if arg1 == arg2 == 'X':
            raise CompilerException(ExceptionType.ARG, command + arg2,
                                    "'X' cannot be both arguments in arithmetic and logic instructions")

        if arg1 != 'X' and arg2 is not None and arg2 != 'X':
            raise CompilerException(ExceptionType.ARG, command + arg2,
                                    "Arithmetic and logic instructions must have at least one argument be 'X'")

        self.add_instruction([command, dst, arg1, arg2])
        return True

    def verify_registers(self, command: Token | str, count: int) -> tuple[Token, ...]:
        """
        Intended for use when parsing an instruction that has register arguments. It simply checks if the next tokens
        are all register tokens, where count specifies how many tokens it checks. Raises helpful exceptions for the
        case where there are not enough arguments and when the arguments are not registers
        Args:
            command: The command for which the arguments are being checked. Purely used for error messages
            count: The number of tokens to check. i.e. the number of arguments to the instruction

        Returns: The tokens checked in a tuple
        Raises:
            CompilerException:
                - If a token checked is not a REGISTER type
        """
        tokens = tuple(self.token(i) for i in range(count))
        for i, token in enumerate(tokens):
            if token.token_type is TokenType.INSTRUCTION_END:
                raise CompilerException(ExceptionType.ARG, command + self.token(i - 1),
                                        f"Expected {count} register arguments in '{command}' instruction")

            if token.token_type is not TokenType.REGISTER:
                raise CompilerException(ExceptionType.ARG, self.token(i),
                                        f"Expected register for argument {i + 1} in '{command}' instruction")

        self.index += count
        return tokens

    def parse_constant_expression(self) -> CodeObject:
        """
        Parses a constant value. A constant is defined as
        ConstantExpression:
            label
            BitwiseOrExpression

        BitwiseOrExpression:
            BitwiseAndExpression ('|' BitwiseAndExpression)*

        BitwiseAndExpression:
            ArithmeticExpression ('&' ArithmeticExpression)*

        ArithmeticExpression:
            UnaryExpression (('+' | '-') UnaryExpression)*

        UnaryExpression:
            ('-' | '!')* Primary

        Primary:
            definition
            integer
            '(' BitwiseOrExpression ')'

        This allows bitwise and arithmetic operations to be performed on definitions and integers, where unary
        operators have the highest precedence followed by (+, -) then &, then |. This grammar prohibits operators from
        being used on labels. If a constant expression is not a label, it will be able to be evaluated completely, since
        all definitions must be defined before they are used.

        Each non-terminal above will be implemented in its own function, which returns the CodeObject representing the
        parsed expression. If it fails to parse an expression, an exception will be raised, as this is only used when
        an expression is required

        Returns:
            (token_type, value): token_type is the type of the expression. If it is a label, then type='identifier',
                otherwise type='integer'. value is the value of the expression. This is returned as a CodeObject, which
                either contains an integer, or a string, if there was a label.
        """
        if self.token().token_type is TokenType.IDENTIFIER and self.token().value not in self.definitions:
            self.used_labels.add(self.token())
            self.index += 1
            return self.token(-1)
        return self.parse_or_expression()

    def parse_or_expression(self) -> CodeObject:
        """See docstring for parse_constant_expression"""
        expression = self.parse_and_expression()
        while self.token().value == '|':
            expression += self.token()
            self.index += 1
            expression = add(expression, self.parse_and_expression(), lambda x, y: x | y)
        return expression

    def parse_and_expression(self) -> CodeObject:
        """See docstring for parse_constant_expression"""
        expression = self.parse_arithmetic_expression()
        while self.token().value == '&':
            expression += self.token()
            self.index += 1
            expression = add(expression, self.parse_arithmetic_expression(), lambda x, y: x & y)
        return expression

    def parse_arithmetic_expression(self) -> CodeObject:
        """See docstring for parse_constant_expression"""
        expression = self.parse_unary_expression()
        token = self.token()
        while token.value in ['+', '-']:
            expression += token
            self.index += 1
            if token.value == '+':
                expression = add(expression, self.parse_unary_expression(), lambda x, y: x + y)
            elif token.value == '-':
                expression = add(expression, self.parse_unary_expression(), lambda x, y: x - y)
            token = self.token()
        return expression

    def parse_unary_expression(self) -> CodeObject:
        """See docstring for parse_constant_expression"""
        minus = False
        invert = False
        text = PositionedString.empty_string()
        while self.token().value in ['-', '!']:
            if self.token().value == '-':
                minus = not minus
            elif self.token().value == '!':
                invert = not invert
            text += self.token()
            self.index += 1
        expression = self.parse_primary()
        result = CodeObject(expression.value, text + expression)
        if minus:
            result.value = -result.value
        if invert:
            result.value = ~result.value
        return result

    def parse_primary(self) -> CodeObject:
        """See docstring for parse_constant_expression"""
        token = self.token()
        if token.token_type is TokenType.IDENTIFIER:
            if token.value in self.definitions:
                self.index += 1
                self.used_definitions.add(token)
                return CodeObject(self.definitions[token.value], token)
            raise CompilerException(
                ExceptionType.NAME, token,
                f"Invalid name, '{token}', used in expression. Constants must be defined before they are used, and "
                f"labels cannot be used in expressions"
            )

        if self.token().token_type is TokenType.INTEGER:
            if not -32768 <= token.value < 65536:
                raise CompilerException(ExceptionType.VALUE, token,
                                        "Integer literals must be in the range -32768 to 65535 (inclusive)")
            self.index += 1
            return token

        if token == '(':
            self.index += 1
            expression = self.parse_or_expression()
            if self.token().value == ')':
                self.index += 1
                return CodeObject(expression.value, token + expression + self.token(-1))
            if self.token().token_type is TokenType.INSTRUCTION_END:
                raise CompilerException(ExceptionType.SYNTAX, token, 'Unmatched bracket')
            else:
                raise CompilerException(ExceptionType.SYNTAX, self.token(), 'Invalid Syntax. Expected closing bracket')

        if token is None:
            raise CompilerException(
                ExceptionType.SYNTAX, self.token(-1),
                "Missing value for '{}' instruction. Expected label, constant, or expression involving constants"
            )
        else:
            raise CompilerException(ExceptionType.SYNTAX, token,
                                    "Unexpected token. Expected label, constant, or expression involving constants")


def write_load(instruction: str, value: int) -> list[list[str | int]]:
    """
    Generates the equivalent assembly instructions for a ldb or ldu instruction. The value argument should be taken
    directly from the value field in the token that represents the argument to this load instruction.
    The argument must be either an identifier or an integer.
    Integer arguments can be up to 16 bits, but only the upper or lower 8 bits will be used, depending on the
    value of instruction. The instruction argument is a string and can be either 'ldu', to load the upper byte,
    or 'ldb' to load the lower byte of the argument

    If the argument is an integer and the eighth bit is a 0, then this will write
        ldb arg       or      ldu arg

    If the argument is an integer and the eighth bit is a 1, then this will write
        ldb !arg      or      ldu !arg
        not L L               not L L
    Where !arg is the 1's complement negation of the argument
    Args:
        instruction: string indicating the type of the load instruction. Can be either 'ldu' for load
            upper byte, or 'ldb' for load lower byte
        value: the value of the argument
    """

    if isinstance(value, str):
        # Leave labels as they are, since they will be resolved in the label_encoder
        return [[instruction, value]]

    instructions = []
    # select the upper or lower 8 bits depending on the value of instr
    value = value & 0xFF if instruction == 'ldb' else (value >> 8) & 0xFF

    # if the eighth bit is zero, simple ldb instruction will work
    if 0 <= value <= 127:
        instructions.append(['ldb', value])

    # Otherwise we have to load the 1's complement of the argument and the invert it
    else:
        instructions.append([instruction, ~value & 0xFF])
        instructions.append(['not', 'L', 'L'])
    return instructions
