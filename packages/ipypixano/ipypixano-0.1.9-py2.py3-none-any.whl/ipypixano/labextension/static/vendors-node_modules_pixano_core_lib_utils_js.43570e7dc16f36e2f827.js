"use strict";
(self["webpackChunkjupyter_pixano"] = self["webpackChunkjupyter_pixano"] || []).push([["vendors-node_modules_pixano_core_lib_utils_js"],{

/***/ "./node_modules/@pixano/core/lib/utils.js":
/*!************************************************!*\
  !*** ./node_modules/@pixano/core/lib/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "colorNames": () => (/* binding */ colorNames),
/* harmony export */   "colors": () => (/* binding */ colors),
/* harmony export */   "searchSorted": () => (/* binding */ searchSorted),
/* harmony export */   "colorToRGBA": () => (/* binding */ colorToRGBA),
/* harmony export */   "hexStringToNumber": () => (/* binding */ hexStringToNumber),
/* harmony export */   "colorToHex": () => (/* binding */ colorToHex),
/* harmony export */   "colorAnyToHex": () => (/* binding */ colorAnyToHex),
/* harmony export */   "rgbToHex": () => (/* binding */ rgbToHex),
/* harmony export */   "colorAnyToHexNumber": () => (/* binding */ colorAnyToHexNumber),
/* harmony export */   "copyClipboard": () => (/* binding */ copyClipboard),
/* harmony export */   "pasteClipboard": () => (/* binding */ pasteClipboard),
/* harmony export */   "intersectionOverUnion": () => (/* binding */ intersectionOverUnion),
/* harmony export */   "isEqual": () => (/* binding */ isEqual),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "RegBlob": () => (/* binding */ RegBlob),
/* harmony export */   "BlobExtractor2d": () => (/* binding */ BlobExtractor2d),
/* harmony export */   "convertIndexToDict": () => (/* binding */ convertIndexToDict),
/* harmony export */   "simplify": () => (/* binding */ simplify),
/* harmony export */   "checkPathExists": () => (/* binding */ checkPathExists)
/* harmony export */ });
const colorNames = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "f00",
    rebeccapurple: "663399",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};
const colors = ['red', 'blue', 'green', 'yellow', 'pink', 'purple', 'orange', 'cyan'];
function searchSorted(arr, value) {
    for (let i = 0; i < arr.length; i++) {
        if (value < arr[i]) {
            return i;
        }
    }
    return arr.length;
}
function colorToRGBA(color) {
    const cvs = document.createElement('canvas');
    cvs.height = 1;
    cvs.width = 1;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1, 1);
    return ctx.getImageData(0, 0, 1, 1).data;
}
function byteToHex(num) {
    return ('0' + num.toString(16)).slice(-2);
}
function hexStringToNumber(color) {
    return parseInt(color, 16);
}
function colorToHex(color) {
    const rgba = colorToRGBA(color);
    const hex = [0, 1, 2].map((idx) => byteToHex(rgba[idx])).join('');
    return "#" + hex;
}
function colorAnyToHex(color) {
    const hex = colorNames[color];
    if (hex) {
        return hex;
    }
    else if (color.startsWith('#')) {
        return color.slice(1);
    }
    return '';
}
function componentToHex(c) {
    const hex = c.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function colorAnyToHexNumber(color) {
    let hex = colorNames[color];
    if (hex) {
        if (hex.length === 3) {
            hex = hex.split('')
                .map((h) => h + h)
                .join('');
        }
        return parseInt(hex, 16);
    }
    else if (color.startsWith('#')) {
        color = color.slice(1);
        if (color.length === 3) {
            color = color.split('')
                .map((h) => h + h)
                .join('');
        }
        return parseInt(color, 16);
    }
    return 0X000000;
}
function copyClipboard(newClip) {
    navigator.clipboard.writeText(newClip).then(() => {
    }, () => {
    });
}
function pasteClipboard() {
    return navigator.clipboard.readText();
}
function intersectionOverUnion(box1, box2) {
    const xmin1 = Math.min(box1[0], box1[2]);
    const ymin1 = Math.min(box1[1], box1[3]);
    const xmax1 = Math.max(box1[0], box1[2]);
    const ymax1 = Math.max(box1[1], box1[3]);
    const xmin2 = Math.min(box2[0], box2[2]);
    const ymin2 = Math.min(box2[1], box2[3]);
    const xmax2 = Math.max(box2[0], box2[2]);
    const ymax2 = Math.max(box2[1], box2[3]);
    const area1 = (ymax1 - ymin1) * (xmax1 - xmin1);
    const area2 = (ymax2 - ymin2) * (xmax2 - xmin2);
    if (area1 <= 0 || area2 <= 0) {
        return 0.0;
    }
    const intersectionYmin = Math.max(ymin1, ymin2);
    const intersectionXmin = Math.max(xmin1, xmin2);
    const intersectionYmax = Math.min(ymax1, ymax2);
    const intersectionXmax = Math.min(xmax1, xmax2);
    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *
        Math.max(intersectionXmax - intersectionXmin, 0.0);
    return intersectionArea / (area1 + area2 - intersectionArea);
}
const isEqual = (value, other) => {
    const type = Object.prototype.toString.call(value);
    if (type !== Object.prototype.toString.call(other))
        return false;
    if (['[object Array]', '[object Object]'].indexOf(type) < 0)
        return false;
    const valueLen = type === '[object Array]' ? value.length : Object.keys(value).length;
    const otherLen = type === '[object Array]' ? other.length : Object.keys(other).length;
    if (valueLen !== otherLen)
        return false;
    const compare = (item1, item2) => {
        const itemType = Object.prototype.toString.call(item1);
        if (['[object Array]', '[object Object]'].indexOf(itemType) >= 0) {
            if (!isEqual(item1, item2))
                return false;
        }
        else {
            if (itemType !== Object.prototype.toString.call(item2))
                return false;
            if (itemType === '[object Function]') {
                if (item1.toString() !== item2.toString())
                    return false;
            }
            else {
                if (item1 !== item2)
                    return false;
            }
        }
        return true;
    };
    if (type === '[object Array]') {
        for (let i = 0; i < valueLen; i++) {
            if (compare(value[i], other[i]) === false)
                return false;
        }
    }
    else {
        for (const key in value) {
            if (value.hasOwnProperty(key)) {
                if (compare(value[key], other[key]) === false)
                    return false;
            }
        }
    }
    return true;
};
function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}
class RegBlob {
    constructor(cls) {
        this.contours = new Array();
        this.nbPixels = 0;
        this.cls = cls;
    }
}
class BlobExtractor2d {
    constructor(data, width, height, augData, vertexExtrema) {
        this.withExtrema = false;
        this.blobs = new Map();
        this.width = width;
        this.height = height;
        this.augW = width + 2;
        this.augH = height + 2;
        data = data || [];
        let [xMin, yMin, xMax, yMax] = [0, 0, 0, 0];
        if (vertexExtrema) {
            [xMin, yMin, xMax, yMax] = vertexExtrema;
            xMax = xMax - 1;
            yMax = yMax - 1;
            this.extrema = [xMin, yMin, xMax, yMax];
            this.withExtrema = true;
        }
        else {
            this.extrema = [0, 1, this.augW - 1, this.augH - 2];
        }
        this.max = this.augH * this.augW;
        this.pos = [1, this.augW + 1, this.augW, this.augW - 1, -1, -this.augW - 1, -this.augW, -this.augW + 1];
        this.label = new Array(this.width * this.height);
        if (augData)
            this.augData = augData;
        else
            this.augData = this.addBorders(data);
        if (vertexExtrema)
            this.extrema = [xMin, yMin + 1, xMax + 2, yMax + 1];
        this.augLabel = new Array(this.max);
        this.targetId = 0;
    }
    origPos(pos, augW) {
        const y = pos / augW | 0;
        const x = pos % augW;
        return (y - 1) * (augW - 2) + x - 1;
    }
    addBorders(data) {
        const augData = new Array((this.augW) * (this.augH));
        const [xMin, yMin, xMax, yMax] = this.extrema;
        if (this.withExtrema) {
            for (let x = xMin; x <= xMax + 2; x++) {
                for (let y = yMin; y <= yMax + 2; y++) {
                    const i = y * this.augW + x;
                    if (x === xMin || y === yMin || x === xMax + 2 || y === yMax + 2) {
                        augData[i] = BlobExtractor2d.BACKGROUND;
                    }
                    else {
                        augData[i] = data[i - (this.width + 2 * y + 1)];
                    }
                }
            }
        }
        else {
            for (let x = 0; x < this.augW; x++) {
                for (let y = 0; y < this.augH; y++) {
                    const i = y * this.augW + x;
                    if (x === 0 || y === 0 || x === this.width + 1 || y === this.height + 1) {
                        augData[i] = BlobExtractor2d.BACKGROUND;
                    }
                    else {
                        augData[i] = data[i - (this.width + 2 * y + 1)];
                    }
                }
            }
        }
        return augData;
    }
    strPtToPos(pixPos, strPos) {
        const pixY = pixPos / this.augW | 0;
        const ptPos = (() => {
            switch (strPos) {
                case 'tl':
                    return pixPos + pixY;
                case 'tr':
                    return pixPos + pixY + 1;
                case 'bl':
                    return pixPos + (this.augW + 1) + pixY;
                default:
                case 'br':
                    return pixPos + (this.augW + 1) + pixY + 1;
            }
        })();
        return this.origPos(ptPos, this.augW + 1);
    }
    addPoints(contour, oldPos, oldQ, newQ) {
        const newAdded = new Array();
        switch (oldQ) {
            case 0:
                switch (newQ) {
                    case 0:
                        newAdded.push(this.strPtToPos(oldPos, "tr"));
                        break;
                    case 2:
                        newAdded.push(this.strPtToPos(oldPos, "tr"));
                        newAdded.push(this.strPtToPos(oldPos, "br"));
                        break;
                    case 4:
                        newAdded.push(this.strPtToPos(oldPos, "tr"));
                        newAdded.push(this.strPtToPos(oldPos, "br"));
                        newAdded.push(this.strPtToPos(oldPos, "bl"));
                        break;
                    case 6:
                        break;
                }
                break;
            case 2:
                switch (newQ) {
                    case 0:
                        break;
                    case 2:
                        newAdded.push(this.strPtToPos(oldPos, "br"));
                        break;
                    case 4:
                        newAdded.push(this.strPtToPos(oldPos, "br"));
                        newAdded.push(this.strPtToPos(oldPos, "bl"));
                        break;
                    case 6:
                        newAdded.push(this.strPtToPos(oldPos, "br"));
                        newAdded.push(this.strPtToPos(oldPos, "bl"));
                        newAdded.push(this.strPtToPos(oldPos, "tl"));
                        break;
                }
                break;
            case 4:
                switch (newQ) {
                    case 0:
                        newAdded.push(this.strPtToPos(oldPos, "bl"));
                        newAdded.push(this.strPtToPos(oldPos, "tl"));
                        newAdded.push(this.strPtToPos(oldPos, "tr"));
                        break;
                    case 2:
                        break;
                    case 4:
                        newAdded.push(this.strPtToPos(oldPos, "bl"));
                        break;
                    case 6:
                        newAdded.push(this.strPtToPos(oldPos, "bl"));
                        newAdded.push(this.strPtToPos(oldPos, "tl"));
                        break;
                }
                break;
            case 6:
                switch (newQ) {
                    case 0:
                        newAdded.push(this.strPtToPos(oldPos, "tl"));
                        newAdded.push(this.strPtToPos(oldPos, "tr"));
                        break;
                    case 2:
                        newAdded.push(this.strPtToPos(oldPos, "tl"));
                        newAdded.push(this.strPtToPos(oldPos, "tr"));
                        newAdded.push(this.strPtToPos(oldPos, "br"));
                        break;
                    case 4:
                        break;
                    case 6:
                        newAdded.push(this.strPtToPos(oldPos, "tl"));
                        break;
                }
                break;
        }
        contour.points.push(...newAdded);
        return contour;
    }
    tracer(S, p) {
        let d = 0;
        while (d < 8) {
            const q = (p + d) % 8;
            const T = S + this.pos[q];
            if (T < 0 || T >= this.max)
                continue;
            if (this.augData[T] === this.targetId)
                return { T, q };
            this.augLabel[T] = BlobExtractor2d.MARKED;
            if (BlobExtractor2d.CONNEXITY === 8)
                d++;
            else
                d = d + 2;
        }
        return { T: S, q: -1 };
    }
    contourTracing(S, C, external) {
        let p;
        if (BlobExtractor2d.CONNEXITY === 8)
            p = external ? 7 : 3;
        else
            p = external ? 0 : 2;
        let contour = { type: external ? "external" : "internal", points: new Array() };
        const addedPixels = new Set();
        let tmp = this.tracer(S, p);
        const T2 = tmp.T;
        let q = tmp.q;
        this.augLabel[S] = C;
        addedPixels.add(S);
        if (T2 === S) {
            if (BlobExtractor2d.CONNEXITY === 4) {
                contour.points.push(this.strPtToPos(S, "tl"));
                contour.points.push(this.strPtToPos(S, "tr"));
                contour.points.push(this.strPtToPos(S, "br"));
                contour.points.push(this.strPtToPos(S, "bl"));
            }
            return [contour, addedPixels.size];
        }
        let Tnext = T2;
        let T = T2;
        while (T !== S || Tnext !== T2) {
            this.augLabel[Tnext] = C;
            if (!addedPixels.has(Tnext))
                addedPixels.add(Tnext);
            T = Tnext;
            if (BlobExtractor2d.CONNEXITY === 8)
                p = (q + 5) % 8;
            else
                p = (q + 6) % 8;
            tmp = this.tracer(T, p);
            if (BlobExtractor2d.CONNEXITY === 4)
                contour = this.addPoints(contour, T, q, tmp.q);
            Tnext = tmp.T;
            q = tmp.q;
        }
        return [contour, addedPixels.size];
    }
    ;
    extract(targetId, needLabel = false) {
        this.targetId = targetId;
        for (let i = this.extrema[0]; i <= this.extrema[2]; i++) {
            for (let j = this.extrema[1]; j <= this.extrema[3]; j++) {
                const posi = i + j * this.augW;
                this.augLabel[posi] = BlobExtractor2d.UNSET;
            }
        }
        let c = 0;
        let y = this.extrema[1];
        do {
            let x = this.extrema[0];
            do {
                const offset = y * this.augW + x;
                if (this.augData[offset] !== this.targetId)
                    continue;
                if (this.augData[offset - this.augW] !== this.targetId && this.augLabel[offset] === BlobExtractor2d.UNSET) {
                    this.blobs.set(c, new RegBlob(c));
                    const [contour, nbPixels] = this.contourTracing(offset, c, true);
                    this.blobs.get(c).contours.push(contour);
                    this.blobs.get(c).nbPixels += nbPixels;
                    c++;
                }
                if (this.augData[offset + this.augW] !== this.targetId && this.augLabel[offset + this.augW] === BlobExtractor2d.UNSET) {
                    let n = this.augLabel[offset - 1];
                    if (this.augLabel[offset] !== BlobExtractor2d.UNSET)
                        n = this.augLabel[offset];
                    const [contour, nbPixels] = this.contourTracing(offset, n, false);
                    const b = this.blobs.get(n);
                    if (b) {
                        b.contours.push(contour);
                        b.nbPixels += nbPixels;
                    }
                }
                if (this.augLabel[offset] === BlobExtractor2d.UNSET) {
                    const n = this.augLabel[offset - 1] || 0;
                    this.augLabel[offset] = n;
                    const b = this.blobs.get(n);
                    if (b) {
                        b.nbPixels += 1;
                    }
                }
            } while (x++ <= this.extrema[2]);
        } while (y++ <= this.extrema[3]);
        if (needLabel) {
            for (let x2 = 0; x2 < this.width; x2++) {
                for (let y2 = 0; y2 < this.height; y2++) {
                    const offset = x2 + y2 * this.width;
                    this.label[offset] = this.augLabel[offset + this.width + 2 * y2 + 3];
                }
            }
        }
    }
}
BlobExtractor2d.BACKGROUND = null;
BlobExtractor2d.UNSET = -1;
BlobExtractor2d.MARKED = -2;
BlobExtractor2d.CONNEXITY = 4;
function convertIndexToDict(indexes, width) {
    return indexes.map((idx) => {
        const y = ((idx / width | 0) / 1.01);
        const x = ((idx % width) / 1.01);
        return [x, y];
    });
}
function getSqDist(p1, p2) {
    const dx = p1[0] - p2[0];
    const dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
    let [x, y] = p1;
    let dx = p2[0] - x;
    let dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
        const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x = p2[0];
            y = p2[1];
        }
        else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
}
function simplifyRadialDist(points, sqTolerance) {
    let prevPoint = points[0];
    const newPoints = [prevPoint];
    let point = [-1, -1];
    for (point of points) {
        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }
    if (prevPoint !== point)
        newPoints.push(point);
    return newPoints;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    let maxSqDist = sqTolerance;
    let index = -1;
    for (let i = first + 1; i < last; i++) {
        const sqDist = getSqSegDist(points[i], points[first], points[last]);
        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }
    if (maxSqDist > sqTolerance) {
        if (index - first > 1)
            simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1)
            simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}
function simplifyDouglasPeucker(points, sqTolerance) {
    const last = points.length - 1;
    const simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);
    return simplified;
}
function simplify(points, tolerance = 1, highestQuality = false) {
    if (points.length <= 2)
        return points;
    const sqTolerance = tolerance * tolerance;
    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);
    return points;
}
function checkPathExists(path) {
    const xhr = new XMLHttpRequest();
    xhr.open('HEAD', path, false);
    xhr.send();
    if (xhr.status === 404) {
        return false;
    }
    else {
        return true;
    }
}
//# sourceMappingURL=utils.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_pixano_core_lib_utils_js.43570e7dc16f36e2f827.js.map