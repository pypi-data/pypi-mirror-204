{"version":3,"file":"vendors-node_modules_pixano_core_lib_utils_js.43570e7dc16f36e2f827.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,KAAK;AACL,KAAK;AACL;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA,6BAA6B,iBAAiB;AAC9C,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyter_pixano/./node_modules/@pixano/core/lib/utils.js"],"sourcesContent":["export const colorNames = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"0ff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"00f\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    burntsienna: \"ea7e5d\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"0ff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"f0f\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    red: \"f00\",\n    rebeccapurple: \"663399\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\nexport const colors = ['red', 'blue', 'green', 'yellow', 'pink', 'purple', 'orange', 'cyan'];\nexport function searchSorted(arr, value) {\n    for (let i = 0; i < arr.length; i++) {\n        if (value < arr[i]) {\n            return i;\n        }\n    }\n    return arr.length;\n}\nexport function colorToRGBA(color) {\n    const cvs = document.createElement('canvas');\n    cvs.height = 1;\n    cvs.width = 1;\n    const ctx = cvs.getContext('2d');\n    ctx.fillStyle = color;\n    ctx.fillRect(0, 0, 1, 1);\n    return ctx.getImageData(0, 0, 1, 1).data;\n}\nfunction byteToHex(num) {\n    return ('0' + num.toString(16)).slice(-2);\n}\nexport function hexStringToNumber(color) {\n    return parseInt(color, 16);\n}\nexport function colorToHex(color) {\n    const rgba = colorToRGBA(color);\n    const hex = [0, 1, 2].map((idx) => byteToHex(rgba[idx])).join('');\n    return \"#\" + hex;\n}\nexport function colorAnyToHex(color) {\n    const hex = colorNames[color];\n    if (hex) {\n        return hex;\n    }\n    else if (color.startsWith('#')) {\n        return color.slice(1);\n    }\n    return '';\n}\nfunction componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n}\nexport function rgbToHex(r, g, b) {\n    return componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\nexport function colorAnyToHexNumber(color) {\n    let hex = colorNames[color];\n    if (hex) {\n        if (hex.length === 3) {\n            hex = hex.split('')\n                .map((h) => h + h)\n                .join('');\n        }\n        return parseInt(hex, 16);\n    }\n    else if (color.startsWith('#')) {\n        color = color.slice(1);\n        if (color.length === 3) {\n            color = color.split('')\n                .map((h) => h + h)\n                .join('');\n        }\n        return parseInt(color, 16);\n    }\n    return 0X000000;\n}\nexport function copyClipboard(newClip) {\n    navigator.clipboard.writeText(newClip).then(() => {\n    }, () => {\n    });\n}\nexport function pasteClipboard() {\n    return navigator.clipboard.readText();\n}\nexport function intersectionOverUnion(box1, box2) {\n    const xmin1 = Math.min(box1[0], box1[2]);\n    const ymin1 = Math.min(box1[1], box1[3]);\n    const xmax1 = Math.max(box1[0], box1[2]);\n    const ymax1 = Math.max(box1[1], box1[3]);\n    const xmin2 = Math.min(box2[0], box2[2]);\n    const ymin2 = Math.min(box2[1], box2[3]);\n    const xmax2 = Math.max(box2[0], box2[2]);\n    const ymax2 = Math.max(box2[1], box2[3]);\n    const area1 = (ymax1 - ymin1) * (xmax1 - xmin1);\n    const area2 = (ymax2 - ymin2) * (xmax2 - xmin2);\n    if (area1 <= 0 || area2 <= 0) {\n        return 0.0;\n    }\n    const intersectionYmin = Math.max(ymin1, ymin2);\n    const intersectionXmin = Math.max(xmin1, xmin2);\n    const intersectionYmax = Math.min(ymax1, ymax2);\n    const intersectionXmax = Math.min(xmax1, xmax2);\n    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n        Math.max(intersectionXmax - intersectionXmin, 0.0);\n    return intersectionArea / (area1 + area2 - intersectionArea);\n}\nexport const isEqual = (value, other) => {\n    const type = Object.prototype.toString.call(value);\n    if (type !== Object.prototype.toString.call(other))\n        return false;\n    if (['[object Array]', '[object Object]'].indexOf(type) < 0)\n        return false;\n    const valueLen = type === '[object Array]' ? value.length : Object.keys(value).length;\n    const otherLen = type === '[object Array]' ? other.length : Object.keys(other).length;\n    if (valueLen !== otherLen)\n        return false;\n    const compare = (item1, item2) => {\n        const itemType = Object.prototype.toString.call(item1);\n        if (['[object Array]', '[object Object]'].indexOf(itemType) >= 0) {\n            if (!isEqual(item1, item2))\n                return false;\n        }\n        else {\n            if (itemType !== Object.prototype.toString.call(item2))\n                return false;\n            if (itemType === '[object Function]') {\n                if (item1.toString() !== item2.toString())\n                    return false;\n            }\n            else {\n                if (item1 !== item2)\n                    return false;\n            }\n        }\n        return true;\n    };\n    if (type === '[object Array]') {\n        for (let i = 0; i < valueLen; i++) {\n            if (compare(value[i], other[i]) === false)\n                return false;\n        }\n    }\n    else {\n        for (const key in value) {\n            if (value.hasOwnProperty(key)) {\n                if (compare(value[key], other[key]) === false)\n                    return false;\n            }\n        }\n    }\n    return true;\n};\nexport function shuffle(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\nexport class RegBlob {\n    constructor(cls) {\n        this.contours = new Array();\n        this.nbPixels = 0;\n        this.cls = cls;\n    }\n}\nexport class BlobExtractor2d {\n    constructor(data, width, height, augData, vertexExtrema) {\n        this.withExtrema = false;\n        this.blobs = new Map();\n        this.width = width;\n        this.height = height;\n        this.augW = width + 2;\n        this.augH = height + 2;\n        data = data || [];\n        let [xMin, yMin, xMax, yMax] = [0, 0, 0, 0];\n        if (vertexExtrema) {\n            [xMin, yMin, xMax, yMax] = vertexExtrema;\n            xMax = xMax - 1;\n            yMax = yMax - 1;\n            this.extrema = [xMin, yMin, xMax, yMax];\n            this.withExtrema = true;\n        }\n        else {\n            this.extrema = [0, 1, this.augW - 1, this.augH - 2];\n        }\n        this.max = this.augH * this.augW;\n        this.pos = [1, this.augW + 1, this.augW, this.augW - 1, -1, -this.augW - 1, -this.augW, -this.augW + 1];\n        this.label = new Array(this.width * this.height);\n        if (augData)\n            this.augData = augData;\n        else\n            this.augData = this.addBorders(data);\n        if (vertexExtrema)\n            this.extrema = [xMin, yMin + 1, xMax + 2, yMax + 1];\n        this.augLabel = new Array(this.max);\n        this.targetId = 0;\n    }\n    origPos(pos, augW) {\n        const y = pos / augW | 0;\n        const x = pos % augW;\n        return (y - 1) * (augW - 2) + x - 1;\n    }\n    addBorders(data) {\n        const augData = new Array((this.augW) * (this.augH));\n        const [xMin, yMin, xMax, yMax] = this.extrema;\n        if (this.withExtrema) {\n            for (let x = xMin; x <= xMax + 2; x++) {\n                for (let y = yMin; y <= yMax + 2; y++) {\n                    const i = y * this.augW + x;\n                    if (x === xMin || y === yMin || x === xMax + 2 || y === yMax + 2) {\n                        augData[i] = BlobExtractor2d.BACKGROUND;\n                    }\n                    else {\n                        augData[i] = data[i - (this.width + 2 * y + 1)];\n                    }\n                }\n            }\n        }\n        else {\n            for (let x = 0; x < this.augW; x++) {\n                for (let y = 0; y < this.augH; y++) {\n                    const i = y * this.augW + x;\n                    if (x === 0 || y === 0 || x === this.width + 1 || y === this.height + 1) {\n                        augData[i] = BlobExtractor2d.BACKGROUND;\n                    }\n                    else {\n                        augData[i] = data[i - (this.width + 2 * y + 1)];\n                    }\n                }\n            }\n        }\n        return augData;\n    }\n    strPtToPos(pixPos, strPos) {\n        const pixY = pixPos / this.augW | 0;\n        const ptPos = (() => {\n            switch (strPos) {\n                case 'tl':\n                    return pixPos + pixY;\n                case 'tr':\n                    return pixPos + pixY + 1;\n                case 'bl':\n                    return pixPos + (this.augW + 1) + pixY;\n                default:\n                case 'br':\n                    return pixPos + (this.augW + 1) + pixY + 1;\n            }\n        })();\n        return this.origPos(ptPos, this.augW + 1);\n    }\n    addPoints(contour, oldPos, oldQ, newQ) {\n        const newAdded = new Array();\n        switch (oldQ) {\n            case 0:\n                switch (newQ) {\n                    case 0:\n                        newAdded.push(this.strPtToPos(oldPos, \"tr\"));\n                        break;\n                    case 2:\n                        newAdded.push(this.strPtToPos(oldPos, \"tr\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"br\"));\n                        break;\n                    case 4:\n                        newAdded.push(this.strPtToPos(oldPos, \"tr\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"br\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"bl\"));\n                        break;\n                    case 6:\n                        break;\n                }\n                break;\n            case 2:\n                switch (newQ) {\n                    case 0:\n                        break;\n                    case 2:\n                        newAdded.push(this.strPtToPos(oldPos, \"br\"));\n                        break;\n                    case 4:\n                        newAdded.push(this.strPtToPos(oldPos, \"br\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"bl\"));\n                        break;\n                    case 6:\n                        newAdded.push(this.strPtToPos(oldPos, \"br\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"bl\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"tl\"));\n                        break;\n                }\n                break;\n            case 4:\n                switch (newQ) {\n                    case 0:\n                        newAdded.push(this.strPtToPos(oldPos, \"bl\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"tl\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"tr\"));\n                        break;\n                    case 2:\n                        break;\n                    case 4:\n                        newAdded.push(this.strPtToPos(oldPos, \"bl\"));\n                        break;\n                    case 6:\n                        newAdded.push(this.strPtToPos(oldPos, \"bl\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"tl\"));\n                        break;\n                }\n                break;\n            case 6:\n                switch (newQ) {\n                    case 0:\n                        newAdded.push(this.strPtToPos(oldPos, \"tl\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"tr\"));\n                        break;\n                    case 2:\n                        newAdded.push(this.strPtToPos(oldPos, \"tl\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"tr\"));\n                        newAdded.push(this.strPtToPos(oldPos, \"br\"));\n                        break;\n                    case 4:\n                        break;\n                    case 6:\n                        newAdded.push(this.strPtToPos(oldPos, \"tl\"));\n                        break;\n                }\n                break;\n        }\n        contour.points.push(...newAdded);\n        return contour;\n    }\n    tracer(S, p) {\n        let d = 0;\n        while (d < 8) {\n            const q = (p + d) % 8;\n            const T = S + this.pos[q];\n            if (T < 0 || T >= this.max)\n                continue;\n            if (this.augData[T] === this.targetId)\n                return { T, q };\n            this.augLabel[T] = BlobExtractor2d.MARKED;\n            if (BlobExtractor2d.CONNEXITY === 8)\n                d++;\n            else\n                d = d + 2;\n        }\n        return { T: S, q: -1 };\n    }\n    contourTracing(S, C, external) {\n        let p;\n        if (BlobExtractor2d.CONNEXITY === 8)\n            p = external ? 7 : 3;\n        else\n            p = external ? 0 : 2;\n        let contour = { type: external ? \"external\" : \"internal\", points: new Array() };\n        const addedPixels = new Set();\n        let tmp = this.tracer(S, p);\n        const T2 = tmp.T;\n        let q = tmp.q;\n        this.augLabel[S] = C;\n        addedPixels.add(S);\n        if (T2 === S) {\n            if (BlobExtractor2d.CONNEXITY === 4) {\n                contour.points.push(this.strPtToPos(S, \"tl\"));\n                contour.points.push(this.strPtToPos(S, \"tr\"));\n                contour.points.push(this.strPtToPos(S, \"br\"));\n                contour.points.push(this.strPtToPos(S, \"bl\"));\n            }\n            return [contour, addedPixels.size];\n        }\n        let Tnext = T2;\n        let T = T2;\n        while (T !== S || Tnext !== T2) {\n            this.augLabel[Tnext] = C;\n            if (!addedPixels.has(Tnext))\n                addedPixels.add(Tnext);\n            T = Tnext;\n            if (BlobExtractor2d.CONNEXITY === 8)\n                p = (q + 5) % 8;\n            else\n                p = (q + 6) % 8;\n            tmp = this.tracer(T, p);\n            if (BlobExtractor2d.CONNEXITY === 4)\n                contour = this.addPoints(contour, T, q, tmp.q);\n            Tnext = tmp.T;\n            q = tmp.q;\n        }\n        return [contour, addedPixels.size];\n    }\n    ;\n    extract(targetId, needLabel = false) {\n        this.targetId = targetId;\n        for (let i = this.extrema[0]; i <= this.extrema[2]; i++) {\n            for (let j = this.extrema[1]; j <= this.extrema[3]; j++) {\n                const posi = i + j * this.augW;\n                this.augLabel[posi] = BlobExtractor2d.UNSET;\n            }\n        }\n        let c = 0;\n        let y = this.extrema[1];\n        do {\n            let x = this.extrema[0];\n            do {\n                const offset = y * this.augW + x;\n                if (this.augData[offset] !== this.targetId)\n                    continue;\n                if (this.augData[offset - this.augW] !== this.targetId && this.augLabel[offset] === BlobExtractor2d.UNSET) {\n                    this.blobs.set(c, new RegBlob(c));\n                    const [contour, nbPixels] = this.contourTracing(offset, c, true);\n                    this.blobs.get(c).contours.push(contour);\n                    this.blobs.get(c).nbPixels += nbPixels;\n                    c++;\n                }\n                if (this.augData[offset + this.augW] !== this.targetId && this.augLabel[offset + this.augW] === BlobExtractor2d.UNSET) {\n                    let n = this.augLabel[offset - 1];\n                    if (this.augLabel[offset] !== BlobExtractor2d.UNSET)\n                        n = this.augLabel[offset];\n                    const [contour, nbPixels] = this.contourTracing(offset, n, false);\n                    const b = this.blobs.get(n);\n                    if (b) {\n                        b.contours.push(contour);\n                        b.nbPixels += nbPixels;\n                    }\n                }\n                if (this.augLabel[offset] === BlobExtractor2d.UNSET) {\n                    const n = this.augLabel[offset - 1] || 0;\n                    this.augLabel[offset] = n;\n                    const b = this.blobs.get(n);\n                    if (b) {\n                        b.nbPixels += 1;\n                    }\n                }\n            } while (x++ <= this.extrema[2]);\n        } while (y++ <= this.extrema[3]);\n        if (needLabel) {\n            for (let x2 = 0; x2 < this.width; x2++) {\n                for (let y2 = 0; y2 < this.height; y2++) {\n                    const offset = x2 + y2 * this.width;\n                    this.label[offset] = this.augLabel[offset + this.width + 2 * y2 + 3];\n                }\n            }\n        }\n    }\n}\nBlobExtractor2d.BACKGROUND = null;\nBlobExtractor2d.UNSET = -1;\nBlobExtractor2d.MARKED = -2;\nBlobExtractor2d.CONNEXITY = 4;\nexport function convertIndexToDict(indexes, width) {\n    return indexes.map((idx) => {\n        const y = ((idx / width | 0) / 1.01);\n        const x = ((idx % width) / 1.01);\n        return [x, y];\n    });\n}\nfunction getSqDist(p1, p2) {\n    const dx = p1[0] - p2[0];\n    const dy = p1[1] - p2[1];\n    return dx * dx + dy * dy;\n}\nfunction getSqSegDist(p, p1, p2) {\n    let [x, y] = p1;\n    let dx = p2[0] - x;\n    let dy = p2[1] - y;\n    if (dx !== 0 || dy !== 0) {\n        const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n        }\n        else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n    dx = p[0] - x;\n    dy = p[1] - y;\n    return dx * dx + dy * dy;\n}\nfunction simplifyRadialDist(points, sqTolerance) {\n    let prevPoint = points[0];\n    const newPoints = [prevPoint];\n    let point = [-1, -1];\n    for (point of points) {\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n    if (prevPoint !== point)\n        newPoints.push(point);\n    return newPoints;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    let maxSqDist = sqTolerance;\n    let index = -1;\n    for (let i = first + 1; i < last; i++) {\n        const sqDist = getSqSegDist(points[i], points[first], points[last]);\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1)\n            simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1)\n            simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    const last = points.length - 1;\n    const simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n    return simplified;\n}\nexport function simplify(points, tolerance = 1, highestQuality = false) {\n    if (points.length <= 2)\n        return points;\n    const sqTolerance = tolerance * tolerance;\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n    return points;\n}\nexport function checkPathExists(path) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('HEAD', path, false);\n    xhr.send();\n    if (xhr.status === 404) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n//# sourceMappingURL=utils.js.map"],"names":[],"sourceRoot":""}