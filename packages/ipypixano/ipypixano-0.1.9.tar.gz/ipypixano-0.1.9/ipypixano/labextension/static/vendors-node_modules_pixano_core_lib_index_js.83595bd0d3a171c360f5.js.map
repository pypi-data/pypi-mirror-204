{"version":3,"file":"vendors-node_modules_pixano_core_lib_index_js.83595bd0d3a171c360f5.js","mappings":";;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnC0F;AACvC;AAClB;AACgE;AACjG;;;;;;;;;;;;;;;;;;;;;;ACJiC;AACM;AACvC;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,gDAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAY;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnHa;;AAEb,OAAO,qBAAqB,EAAE,mBAAO,CAAC,kEAAiB;AACvD,kBAAkB,mBAAO,CAAC,oEAAkB;AAC5C,aAAa,mBAAO,CAAC,wDAAY;AACjC,iBAAiB,mBAAO,CAAC,kEAAiB;AAC1C,mBAAmB,mBAAO,CAAC,sEAAmB;AAC9C,qBAAqB,mBAAO,CAAC,0EAAqB;AAClD,uBAAuB,mBAAO,CAAC,8EAAuB;AACtD,cAAc,mBAAO,CAAC,0DAAa;AACnC,mBAAmB,mBAAO,CAAC,sEAAmB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,QAAQ,mCAAmC;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3Ma;;AAEb,aAAa,mBAAO,CAAC,oDAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4DAA4D;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJa;;AAEb,iBAAiB,mBAAO,CAAC,8DAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTa;;AAEb;;;;;;;;;;;;ACFa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;;;;;;;;;;;ACba;;AAEb;;;;;;;;;;;;ACFa;;AAEb;;;;;;;;;;;;ACFa;;AAEb;;;;;;;;;;;;ACFa;;AAEb,OAAO,gBAAgB,EAAE,mBAAO,CAAC,8DAAa;AAC9C,gBAAgB,mBAAO,CAAC,4DAAY;AACpC,iBAAiB,mBAAO,CAAC,8DAAa;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGa;;AAEb,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,gBAAgB,mBAAO,CAAC,4DAAY;AACpC,kBAAkB,mBAAO,CAAC,gEAAc;AACxC,iBAAiB,mBAAO,CAAC,8DAAa;;AAEtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS,MAAM;;AAEf;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClQa;;AAEb,OAAO,QAAQ,EAAE,mBAAO,CAAC,8DAAa;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA","sources":["webpack://jupyter_pixano/./node_modules/@pixano/core/lib/event-emitter.js","webpack://jupyter_pixano/./node_modules/@pixano/core/lib/index.js","webpack://jupyter_pixano/./node_modules/@pixano/core/lib/observer.js","webpack://jupyter_pixano/./node_modules/on-change/index.js","webpack://jupyter_pixano/./node_modules/on-change/lib/cache.js","webpack://jupyter_pixano/./node_modules/on-change/lib/constants.js","webpack://jupyter_pixano/./node_modules/on-change/lib/ignore-property.js","webpack://jupyter_pixano/./node_modules/on-change/lib/is-array.js","webpack://jupyter_pixano/./node_modules/on-change/lib/is-builtin.js","webpack://jupyter_pixano/./node_modules/on-change/lib/is-iterator.js","webpack://jupyter_pixano/./node_modules/on-change/lib/is-object.js","webpack://jupyter_pixano/./node_modules/on-change/lib/is-symbol.js","webpack://jupyter_pixano/./node_modules/on-change/lib/path.js","webpack://jupyter_pixano/./node_modules/on-change/lib/smart-clone.js","webpack://jupyter_pixano/./node_modules/on-change/lib/wrap-iterator.js"],"sourcesContent":["export class BasicEventTarget {\n    constructor() {\n        this.listeners = new Map();\n    }\n    addEventListener(type, listener) {\n        const listeners = this.listeners.get(type);\n        if (listeners) {\n            listeners.push(listener);\n        }\n        else {\n            this.listeners.set(type, [listener]);\n        }\n    }\n    removeEventListener(type, listener) {\n        const listeners = this.listeners.get(type);\n        if (listeners) {\n            const i = listeners.indexOf(listener);\n            if (i >= 0) {\n                listeners.splice(i, 1);\n            }\n        }\n    }\n    dispatchEvent(event) {\n        const listeners = this.listeners.get(event.type);\n        if (listeners) {\n            for (const listener of listeners) {\n                listener.call(this, event);\n            }\n            return !event.defaultPrevented;\n        }\n        else {\n            return true;\n        }\n    }\n}\n//# sourceMappingURL=event-emitter.js.map","import { observable, ObservableMap, ObservableSet, observe, unobserve } from './observer';\nimport { BasicEventTarget } from './event-emitter';\nimport * as utils from './utils';\nexport { observable, ObservableMap, ObservableSet, observe, unobserve, BasicEventTarget, utils };\n//# sourceMappingURL=index.js.map","import onChange from 'on-change';\nimport { searchSorted } from './utils';\nconst observers = new WeakMap();\nconst observersOrder = new WeakMap();\nexport function observable(obj) {\n    if (observers.has(obj)) {\n        return obj;\n    }\n    const wrapped = onChange(obj, function (path, value) {\n        for (const cb of [...observers.get(this)]) {\n            cb(path, value);\n        }\n    });\n    observers.set(wrapped, []);\n    observersOrder.set(wrapped, []);\n    return wrapped;\n}\nexport class ObservableSet extends Set {\n    constructor(...args) {\n        super(...args);\n        observers.set(this, []);\n        observersOrder.set(this, []);\n    }\n    add(value) {\n        super.add(value);\n        for (const cb of [...observers.get(this)]) {\n            cb('add', value);\n        }\n        return this;\n    }\n    delete(value) {\n        const success = super.delete(value);\n        for (const cb of [...observers.get(this)]) {\n            cb('delete', value);\n        }\n        return success;\n    }\n    clear() {\n        if (this.size) {\n            super.clear();\n            for (const cb of [...observers.get(this)]) {\n                cb('clear');\n            }\n        }\n    }\n    set(values) {\n        super.clear();\n        values.forEach((v) => {\n            super.add(v);\n        });\n        for (const cb of [...observers.get(this)]) {\n            cb('set', values);\n        }\n    }\n}\nexport class ObservableMap extends Map {\n    constructor(...args) {\n        super(...args);\n        observers.set(this, []);\n        observersOrder.set(this, []);\n    }\n    set(key, value) {\n        super.set(key, value);\n        for (const cb of [...observers.get(this)]) {\n            cb('set', value);\n        }\n        return this;\n    }\n    delete(key) {\n        const success = super.delete(key);\n        for (const cb of [...observers.get(this)]) {\n            cb('delete', key);\n        }\n        return success;\n    }\n    clear() {\n        const success = super.clear();\n        for (const cb of [...observers.get(this)]) {\n            cb('clear');\n        }\n        return success;\n    }\n    init(items) {\n        super.clear();\n        for (const item of items) {\n            super.set(item[0], item[1]);\n        }\n        for (const cb of [...observers.get(this)]) {\n            cb('init');\n        }\n    }\n}\nexport function observe(target, observer, order = 10) {\n    const _observers = observers.get(target);\n    const _observersOrder = observersOrder.get(target);\n    if (!_observers || !_observersOrder) {\n        throw new Error(\"object is not observable. \"\n            + \"If you meant to observe its properties, use `observable` first.\");\n    }\n    const i = searchSorted(_observersOrder, order);\n    _observers.splice(i, 0, observer);\n    _observersOrder.splice(i, 0, order);\n    return observer;\n}\nexport function unobserve(target, observer) {\n    const _observers = observers.get(target);\n    const _observersOrder = observersOrder.get(target);\n    if (_observers && _observersOrder) {\n        const i = _observers.indexOf(observer);\n        if (i >= 0) {\n            _observers.splice(i, 1);\n            _observersOrder.splice(i, 1);\n        }\n    }\n}\n//# sourceMappingURL=observer.js.map","'use strict';\n\nconst {TARGET, UNSUBSCRIBE} = require('./lib/constants');\nconst isBuiltin = require('./lib/is-builtin');\nconst path = require('./lib/path');\nconst isSymbol = require('./lib/is-symbol');\nconst isIterator = require('./lib/is-iterator');\nconst wrapIterator = require('./lib/wrap-iterator');\nconst ignoreProperty = require('./lib/ignore-property');\nconst Cache = require('./lib/cache');\nconst SmartClone = require('./lib/smart-clone');\n\nconst defaultOptions = {\n\tequals: Object.is,\n\tisShallow: false,\n\tpathAsArray: false,\n\tignoreSymbols: false,\n\tignoreUnderscores: false,\n\tignoreDetached: false\n};\n\nconst onChange = (object, onChange, options = {}) => {\n\toptions = {\n\t\t...defaultOptions,\n\t\t...options\n\t};\n\tconst proxyTarget = Symbol('ProxyTarget');\n\tconst {equals, isShallow, ignoreDetached} = options;\n\tconst cache = new Cache(equals);\n\tconst smartClone = new SmartClone();\n\n\tconst handleChangeOnTarget = (target, property, previous, value) => {\n\t\tif (\n\t\t\t!ignoreProperty(cache, options, property) &&\n\t\t\t!(ignoreDetached && cache.isDetached(target, object))\n\t\t) {\n\t\t\thandleChange(cache.getPath(target), property, previous, value);\n\t\t}\n\t};\n\n\t// eslint-disable-next-line max-params\n\tconst handleChange = (changePath, property, previous, value, name) => {\n\t\tif (smartClone.isCloning) {\n\t\t\tsmartClone.update(changePath, property, previous);\n\t\t} else {\n\t\t\tonChange(path.concat(changePath, property), value, previous, name);\n\t\t}\n\t};\n\n\tconst getProxyTarget = value => {\n\t\tif (value) {\n\t\t\treturn value[proxyTarget] || value;\n\t\t}\n\n\t\treturn value;\n\t};\n\n\tconst prepareValue = (value, target, property, basePath) => {\n\t\tif (\n\t\t\tisBuiltin.withoutMutableMethods(value) ||\n\t\t\tproperty === 'constructor' ||\n\t\t\t(isShallow && !SmartClone.isHandledMethod(target, property)) ||\n\t\t\tignoreProperty(cache, options, property) ||\n\t\t\tcache.isGetInvariant(target, property) ||\n\t\t\t(ignoreDetached && cache.isDetached(target, object))\n\t\t) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (basePath === undefined) {\n\t\t\tbasePath = cache.getPath(target);\n\t\t}\n\n\t\treturn cache.getProxy(value, path.concat(basePath, property), handler, proxyTarget);\n\t};\n\n\tconst handler = {\n\t\tget(target, property, receiver) {\n\t\t\tif (isSymbol(property)) {\n\t\t\t\tif (property === proxyTarget || property === TARGET) {\n\t\t\t\t\treturn target;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tproperty === UNSUBSCRIBE &&\n\t\t\t\t\t!cache.isUnsubscribed &&\n\t\t\t\t\tcache.getPath(target).length === 0\n\t\t\t\t) {\n\t\t\t\t\tcache.unsubscribe();\n\t\t\t\t\treturn target;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst value = isBuiltin.withMutableMethods(target) ?\n\t\t\t\tReflect.get(target, property) :\n\t\t\t\tReflect.get(target, property, receiver);\n\n\t\t\treturn prepareValue(value, target, property);\n\t\t},\n\n\t\tset(target, property, value, receiver) {\n\t\t\tvalue = getProxyTarget(value);\n\n\t\t\tconst reflectTarget = target[proxyTarget] || target;\n\t\t\tconst previous = reflectTarget[property];\n\t\t\tconst hasProperty = property in target;\n\n\t\t\tif (cache.setProperty(reflectTarget, property, value, receiver, previous)) {\n\t\t\t\tif (!equals(previous, value) || !hasProperty) {\n\t\t\t\t\thandleChangeOnTarget(target, property, previous, value);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\tdefineProperty(target, property, descriptor) {\n\t\t\tif (!cache.isSameDescriptor(descriptor, target, property)) {\n\t\t\t\tif (!cache.defineProperty(target, property, descriptor)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\thandleChangeOnTarget(target, property, undefined, descriptor.value);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, property) {\n\t\t\tif (!Reflect.has(target, property)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst previous = Reflect.get(target, property);\n\n\t\t\tif (cache.deleteProperty(target, property, previous)) {\n\t\t\t\thandleChangeOnTarget(target, property, previous);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\tapply(target, thisArg, argumentsList) {\n\t\t\tconst thisProxyTarget = thisArg[proxyTarget] || thisArg;\n\n\t\t\tif (cache.isUnsubscribed) {\n\t\t\t\treturn Reflect.apply(target, thisProxyTarget, argumentsList);\n\t\t\t}\n\n\t\t\tif (SmartClone.isHandledType(thisProxyTarget)) {\n\t\t\t\tconst applyPath = path.initial(cache.getPath(target));\n\t\t\t\tconst isHandledMethod = SmartClone.isHandledMethod(thisProxyTarget, target.name);\n\n\t\t\t\tsmartClone.start(thisProxyTarget, applyPath, argumentsList);\n\n\t\t\t\tconst result = Reflect.apply(\n\t\t\t\t\ttarget,\n\t\t\t\t\tsmartClone.preferredThisArg(target, thisArg, thisProxyTarget),\n\t\t\t\t\tisHandledMethod ?\n\t\t\t\t\t\targumentsList.map(argument => getProxyTarget(argument)) :\n\t\t\t\t\t\targumentsList\n\t\t\t\t);\n\n\t\t\t\tconst isChanged = smartClone.isChanged(thisProxyTarget, equals, argumentsList);\n\t\t\t\tconst clone = smartClone.stop();\n\n\t\t\t\tif (isChanged) {\n\t\t\t\t\tif (smartClone.isCloning) {\n\t\t\t\t\t\thandleChange(path.initial(applyPath), path.last(applyPath), clone, thisProxyTarget, target.name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleChange(applyPath, '', clone, thisProxyTarget, target.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(thisArg instanceof Map || thisArg instanceof Set) &&\n\t\t\t\t\tisIterator(result)\n\t\t\t\t) {\n\t\t\t\t\treturn wrapIterator(result, target, thisArg, applyPath, prepareValue);\n\t\t\t\t}\n\n\t\t\t\treturn (SmartClone.isHandledType(result) && isHandledMethod) ?\n\t\t\t\t\tcache.getProxy(result, applyPath, handler, proxyTarget) :\n\t\t\t\t\tresult;\n\t\t\t}\n\n\t\t\treturn Reflect.apply(target, thisArg, argumentsList);\n\t\t}\n\t};\n\n\tconst proxy = cache.getProxy(object, options.pathAsArray ? [] : '', handler);\n\tonChange = onChange.bind(proxy);\n\n\treturn proxy;\n};\n\nonChange.target = proxy => proxy[TARGET] || proxy;\nonChange.unsubscribe = proxy => proxy[UNSUBSCRIBE] || proxy;\n\nmodule.exports = onChange;\n","'use strict';\n\nconst path = require('./path');\n\n/**\n * @class Cache\n * @private\n */\nclass Cache {\n\tconstructor(equals) {\n\t\tthis._equals = equals;\n\t\tthis._proxyCache = new WeakMap();\n\t\tthis._pathCache = new WeakMap();\n\t\tthis.isUnsubscribed = false;\n\t}\n\n\t_getDescriptorCache() {\n\t\tif (this._descriptorCache === undefined) {\n\t\t\tthis._descriptorCache = new WeakMap();\n\t\t}\n\n\t\treturn this._descriptorCache;\n\t}\n\n\t_getProperties(target) {\n\t\tconst descriptorCache = this._getDescriptorCache();\n\t\tlet properties = descriptorCache.get(target);\n\n\t\tif (properties === undefined) {\n\t\t\tproperties = {};\n\t\t\tdescriptorCache.set(target, properties);\n\t\t}\n\n\t\treturn properties;\n\t}\n\n\t_getOwnPropertyDescriptor(target, property) {\n\t\tif (this.isUnsubscribed) {\n\t\t\treturn Reflect.getOwnPropertyDescriptor(target, property);\n\t\t}\n\n\t\tconst properties = this._getProperties(target);\n\t\tlet descriptor = properties[property];\n\n\t\tif (descriptor === undefined) {\n\t\t\tdescriptor = Reflect.getOwnPropertyDescriptor(target, property);\n\t\t\tproperties[property] = descriptor;\n\t\t}\n\n\t\treturn descriptor;\n\t}\n\n\tgetProxy(target, path, handler, proxyTarget) {\n\t\tif (this.isUnsubscribed) {\n\t\t\treturn target;\n\t\t}\n\n\t\tthis._pathCache.set(target, path);\n\n\t\tlet proxy = this._proxyCache.get(target);\n\n\t\tif (proxy === undefined) {\n\t\t\tproxy = target[proxyTarget] === undefined ?\n\t\t\t\tnew Proxy(target, handler) :\n\t\t\t\ttarget;\n\n\t\t\tthis._proxyCache.set(target, proxy);\n\t\t}\n\n\t\treturn proxy;\n\t}\n\n\tgetPath(target) {\n\t\treturn this.isUnsubscribed ? undefined : this._pathCache.get(target);\n\t}\n\n\tisDetached(target, object) {\n\t\tpath.walk(this.getPath(target), key => {\n\t\t\tif (object) {\n\t\t\t\tobject = object[key];\n\t\t\t}\n\t\t});\n\n\t\treturn !Object.is(target, object);\n\t}\n\n\tdefineProperty(target, property, descriptor) {\n\t\tif (!Reflect.defineProperty(target, property, descriptor)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.isUnsubscribed) {\n\t\t\tthis._getProperties(target)[property] = descriptor;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetProperty(target, property, value, receiver, previous) { // eslint-disable-line max-params\n\t\tif (!this._equals(previous, value) || !(property in target)) {\n\t\t\tconst descriptor = this._getOwnPropertyDescriptor(target, property);\n\n\t\t\tif (descriptor !== undefined && 'set' in descriptor) {\n\t\t\t\treturn Reflect.set(target, property, value, receiver);\n\t\t\t}\n\n\t\t\treturn Reflect.set(target, property, value);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tdeleteProperty(target, property, previous) {\n\t\tif (Reflect.deleteProperty(target, property)) {\n\t\t\tif (!this.isUnsubscribed) {\n\t\t\t\tconst properties = this._getDescriptorCache().get(target);\n\n\t\t\t\tif (properties) {\n\t\t\t\t\tdelete properties[property];\n\t\t\t\t\tthis._pathCache.delete(previous);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tisSameDescriptor(a, target, property) {\n\t\tconst b = this._getOwnPropertyDescriptor(target, property);\n\n\t\treturn a !== undefined &&\n\t\t\tb !== undefined &&\n\t\t\tObject.is(a.value, b.value) &&\n\t\t\t(a.writable || false) === (b.writable || false) &&\n\t\t\t(a.enumerable || false) === (b.enumerable || false) &&\n\t\t\t(a.configurable || false) === (b.configurable || false) &&\n\t\t\ta.get === b.get &&\n\t\t\ta.set === b.set;\n\t}\n\n\tisGetInvariant(target, property) {\n\t\tconst descriptor = this._getOwnPropertyDescriptor(target, property);\n\n\t\treturn descriptor !== undefined &&\n\t\t\tdescriptor.configurable !== true &&\n\t\t\tdescriptor.writable !== true;\n\t}\n\n\tunsubscribe() {\n\t\tthis._descriptorCache = null;\n\t\tthis._pathCache = null;\n\t\tthis._proxyCache = null;\n\t\tthis.isUnsubscribed = true;\n\t}\n}\n\nmodule.exports = Cache;\n","module.exports = {\n\tPATH_SEPARATOR: '.',\n\tTARGET: Symbol('target'),\n\tUNSUBSCRIBE: Symbol('unsubscribe')\n};\n","'use strict';\n\nconst isSymbol = require('./is-symbol');\n\nmodule.exports = (cache, options, property) => {\n\treturn cache.isUnsubscribed ||\n\t\t(options.ignoreSymbols && isSymbol(property)) ||\n\t\t(options.ignoreUnderscores && property.charAt(0) === '_') ||\n\t\t('ignoreKeys' in options && options.ignoreKeys.includes(property));\n};\n","'use strict';\n\nmodule.exports = Array.isArray;\n","'use strict';\n\nconst isBuiltin = {\n\twithMutableMethods: value => {\n\t\treturn value instanceof Date ||\n\t\t\tvalue instanceof Set ||\n\t\t\tvalue instanceof Map ||\n\t\t\tvalue instanceof WeakSet ||\n\t\t\tvalue instanceof WeakMap;\n\t},\n\twithoutMutableMethods: value => (typeof value === 'object' ? value === null : typeof value !== 'function') || value instanceof RegExp\n};\n\nmodule.exports = isBuiltin;\n","'use strict';\n\nmodule.exports = value => typeof value === 'object' && typeof value.next === 'function';\n","'use strict';\n\nmodule.exports = value => toString.call(value) === '[object Object]';\n","'use strict';\n\nmodule.exports = value => typeof value === 'symbol';\n","'use strict';\n\nconst {PATH_SEPARATOR} = require('./constants');\nconst isArray = require('./is-array');\nconst isSymbol = require('./is-symbol');\n\nmodule.exports = {\n\tafter: (path, subPath) => {\n\t\tif (isArray(path)) {\n\t\t\treturn path.slice(subPath.length);\n\t\t}\n\n\t\tif (subPath === '') {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn path.slice(subPath.length + 1);\n\t},\n\tconcat: (path, key) => {\n\t\tif (isArray(path)) {\n\t\t\tpath = path.slice();\n\n\t\t\tif (key) {\n\t\t\t\tpath.push(key);\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n\t\tif (key && key.toString !== undefined) {\n\t\t\tif (path !== '') {\n\t\t\t\tpath += PATH_SEPARATOR;\n\t\t\t}\n\n\t\t\tif (isSymbol(key)) {\n\t\t\t\treturn path + key.toString();\n\t\t\t}\n\n\t\t\treturn path + key;\n\t\t}\n\n\t\treturn path;\n\t},\n\tinitial: path => {\n\t\tif (isArray(path)) {\n\t\t\treturn path.slice(0, -1);\n\t\t}\n\n\t\tif (path === '') {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst index = path.lastIndexOf(PATH_SEPARATOR);\n\n\t\tif (index === -1) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn path.slice(0, index);\n\t},\n\tlast: path => {\n\t\tif (isArray(path)) {\n\t\t\treturn path[path.length - 1] || '';\n\t\t}\n\n\t\tif (path === '') {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst index = path.lastIndexOf(PATH_SEPARATOR);\n\n\t\tif (index === -1) {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn path.slice(index + 1);\n\t},\n\twalk: (path, callback) => {\n\t\tif (isArray(path)) {\n\t\t\tpath.forEach(key => callback(key));\n\t\t} else if (path !== '') {\n\t\t\tlet position = 0;\n\t\t\tlet index = path.indexOf(PATH_SEPARATOR);\n\n\t\t\tif (index === -1) {\n\t\t\t\tcallback(path);\n\t\t\t} else {\n\t\t\t\twhile (position < path.length) {\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\tindex = path.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(path.slice(position, index));\n\n\t\t\t\t\tposition = index + 1;\n\t\t\t\t\tindex = path.indexOf(PATH_SEPARATOR, position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n","'use strict';\n\nconst path = require('./path');\nconst isArray = require('./is-array');\nconst isBuiltin = require('./is-builtin');\nconst isObject = require('./is-object');\n\nconst certainChange = () => true;\n\nconst shallowEqualArrays = (clone, value) => {\n\treturn clone.length !== value.length || clone.some((item, index) => value[index] !== item);\n};\n\nconst shallowEqualSets = (clone, value) => {\n\tif (clone.size !== value.size) {\n\t\treturn true;\n\t}\n\n\tfor (const element of clone) {\n\t\tif (!value.has(element)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nconst shallowEqualMaps = (clone, value) => {\n\tif (clone.size !== value.size) {\n\t\treturn true;\n\t}\n\n\tlet bValue;\n\tfor (const [key, aValue] of clone) {\n\t\tbValue = value.get(key);\n\n\t\tif (bValue !== aValue || (bValue === undefined && !value.has(key))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nconst IMMUTABLE_OBJECT_METHODS = new Set([\n\t'hasOwnProperty',\n\t'isPrototypeOf',\n\t'propertyIsEnumerable',\n\t'toLocaleString',\n\t'toString',\n\t'valueOf'\n]);\n\nconst IMMUTABLE_ARRAY_METHODS = new Set([\n\t'concat',\n\t'includes',\n\t'indexOf',\n\t'join',\n\t'keys',\n\t'lastIndexOf'\n]);\n\nconst IMMUTABLE_SET_METHODS = new Set([\n\t'has',\n\t'toString'\n]);\n\nconst IMMUTABLE_MAP_METHODS = new Set([...IMMUTABLE_SET_METHODS].concat(['get']));\n\nconst SHALLOW_MUTABLE_ARRAY_METHODS = {\n\tpush: certainChange,\n\tpop: certainChange,\n\tshift: certainChange,\n\tunshift: certainChange,\n\tcopyWithin: shallowEqualArrays,\n\treverse: shallowEqualArrays,\n\tsort: shallowEqualArrays,\n\tsplice: shallowEqualArrays,\n\tflat: shallowEqualArrays,\n\tfill: shallowEqualArrays\n};\n\nconst SHALLOW_MUTABLE_SET_METHODS = {\n\tadd: shallowEqualSets,\n\tclear: shallowEqualSets,\n\tdelete: shallowEqualSets\n};\n\nconst COLLECTION_ITERATOR_METHODS = [\n\t'keys',\n\t'values',\n\t'entries'\n];\n\nconst SHALLOW_MUTABLE_MAP_METHODS = {\n\tset: shallowEqualMaps,\n\tclear: shallowEqualMaps,\n\tdelete: shallowEqualMaps\n};\n\nconst HANDLED_ARRAY_METHODS = new Set([...IMMUTABLE_OBJECT_METHODS]\n\t.concat([...IMMUTABLE_ARRAY_METHODS])\n\t.concat(Object.keys(SHALLOW_MUTABLE_ARRAY_METHODS)));\n\nconst HANDLED_SET_METHODS = new Set([...IMMUTABLE_SET_METHODS]\n\t.concat(Object.keys(SHALLOW_MUTABLE_SET_METHODS))\n\t.concat(COLLECTION_ITERATOR_METHODS));\n\nconst HANDLED_MAP_METHODS = new Set([...IMMUTABLE_MAP_METHODS]\n\t.concat(Object.keys(SHALLOW_MUTABLE_MAP_METHODS))\n\t.concat(COLLECTION_ITERATOR_METHODS));\n\nclass Clone {\n\tconstructor(value, path, argumentsList) {\n\t\tthis._path = path;\n\t\tthis._isChanged = false;\n\t\tthis._clonedCache = new Set();\n\n\t\tif (value instanceof WeakSet) {\n\t\t\tthis._weakValue = value.has(argumentsList[0]);\n\t\t} else if (value instanceof WeakMap) {\n\t\t\tthis._weakValue = value.get(argumentsList[0]);\n\t\t} else {\n\t\t\tthis.clone = path === undefined ? value : this._shallowClone(value);\n\t\t}\n\t}\n\n\t_shallowClone(value) {\n\t\tlet clone;\n\n\t\tif (isObject(value)) {\n\t\t\tclone = {...value};\n\t\t} else if (isArray(value)) {\n\t\t\tclone = [...value];\n\t\t} else if (value instanceof Date) {\n\t\t\tclone = new Date(value);\n\t\t} else if (value instanceof Set) {\n\t\t\tclone = new Set(value);\n\t\t} else if (value instanceof Map) {\n\t\t\tclone = new Map(value);\n\t\t}\n\n\t\tthis._clonedCache.add(clone);\n\n\t\treturn clone;\n\t}\n\n\tpreferredThisArg(target, thisArg, thisProxyTarget) {\n\t\tconst {name} = target;\n\n\t\tif (SmartClone.isHandledMethod(thisProxyTarget, name)) {\n\t\t\tif (isArray(thisProxyTarget)) {\n\t\t\t\tthis._onIsChanged = SHALLOW_MUTABLE_ARRAY_METHODS[name];\n\t\t\t} else if (thisProxyTarget instanceof Set) {\n\t\t\t\tthis._onIsChanged = SHALLOW_MUTABLE_SET_METHODS[name];\n\t\t\t} else if (thisProxyTarget instanceof Map) {\n\t\t\t\tthis._onIsChanged = SHALLOW_MUTABLE_MAP_METHODS[name];\n\t\t\t}\n\n\t\t\treturn thisProxyTarget;\n\t\t}\n\n\t\treturn thisArg;\n\t}\n\n\tupdate(fullPath, property, value) {\n\t\tif (value !== undefined && property !== 'length') {\n\t\t\tlet object = this.clone;\n\n\t\t\tpath.walk(path.after(fullPath, this._path), key => {\n\t\t\t\tif (!this._clonedCache.has(object[key])) {\n\t\t\t\t\tobject[key] = this._shallowClone(object[key]);\n\t\t\t\t}\n\n\t\t\t\tobject = object[key];\n\t\t\t});\n\n\t\t\tobject[property] = value;\n\t\t}\n\n\t\tthis._isChanged = true;\n\t}\n\n\tisChanged(value, equals, argumentsList) {\n\t\tif (value instanceof Date) {\n\t\t\treturn !equals(this.clone.valueOf(), value.valueOf());\n\t\t}\n\n\t\tif (value instanceof WeakSet) {\n\t\t\treturn this._weakValue !== value.has(argumentsList[0]);\n\t\t}\n\n\t\tif (value instanceof WeakMap) {\n\t\t\treturn this._weakValue !== value.get(argumentsList[0]);\n\t\t}\n\n\t\treturn this._onIsChanged === undefined ?\n\t\t\tthis._isChanged :\n\t\t\tthis._onIsChanged(this.clone, value);\n\t}\n}\n\nclass SmartClone {\n\tconstructor() {\n\t\tthis.stack = [];\n\t}\n\n\tstatic isHandledType(value) {\n\t\treturn isObject(value) ||\n\t\t\tisArray(value) ||\n\t\t\tisBuiltin.withMutableMethods(value);\n\t}\n\n\tstatic isHandledMethod(target, name) {\n\t\tif (isObject(target)) {\n\t\t\treturn IMMUTABLE_OBJECT_METHODS.has(name);\n\t\t}\n\n\t\tif (isArray(target)) {\n\t\t\treturn HANDLED_ARRAY_METHODS.has(name);\n\t\t}\n\n\t\tif (target instanceof Set) {\n\t\t\treturn HANDLED_SET_METHODS.has(name);\n\t\t}\n\n\t\tif (target instanceof Map) {\n\t\t\treturn HANDLED_MAP_METHODS.has(name);\n\t\t}\n\n\t\treturn isBuiltin.withMutableMethods(target);\n\t}\n\n\tget isCloning() {\n\t\treturn this.stack.length !== 0;\n\t}\n\n\tstart(value, path, argumentsList) {\n\t\tthis.stack.push(new Clone(value, path, argumentsList));\n\t}\n\n\tupdate(fullPath, property, value) {\n\t\tthis.stack[this.stack.length - 1].update(fullPath, property, value);\n\t}\n\n\tpreferredThisArg(target, thisArg, thisProxyTarget) {\n\t\treturn this.stack[this.stack.length - 1].preferredThisArg(target, thisArg, thisProxyTarget);\n\t}\n\n\tisChanged(isMutable, value, equals, argumentsList) {\n\t\treturn this.stack[this.stack.length - 1].isChanged(isMutable, value, equals, argumentsList);\n\t}\n\n\tstop() {\n\t\treturn this.stack.pop().clone;\n\t}\n}\n\nmodule.exports = SmartClone;\n","'use strict';\n\nconst {TARGET} = require('./constants');\n\n// eslint-disable-next-line max-params\nmodule.exports = (iterator, target, thisArg, applyPath, prepareValue) => {\n\tconst originalNext = iterator.next;\n\n\tif (target.name === 'entries') {\n\t\titerator.next = function () {\n\t\t\tconst result = originalNext.call(this);\n\n\t\t\tif (result.done === false) {\n\t\t\t\tresult.value[0] = prepareValue(\n\t\t\t\t\tresult.value[0],\n\t\t\t\t\ttarget,\n\t\t\t\t\tresult.value[0],\n\t\t\t\t\tapplyPath\n\t\t\t\t);\n\t\t\t\tresult.value[1] = prepareValue(\n\t\t\t\t\tresult.value[1],\n\t\t\t\t\ttarget,\n\t\t\t\t\tresult.value[0],\n\t\t\t\t\tapplyPath\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t} else if (target.name === 'values') {\n\t\tconst keyIterator = thisArg[TARGET].keys();\n\n\t\titerator.next = function () {\n\t\t\tconst result = originalNext.call(this);\n\n\t\t\tif (result.done === false) {\n\t\t\t\tresult.value = prepareValue(\n\t\t\t\t\tresult.value,\n\t\t\t\t\ttarget,\n\t\t\t\t\tkeyIterator.next().value,\n\t\t\t\t\tapplyPath\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t} else {\n\t\titerator.next = function () {\n\t\t\tconst result = originalNext.call(this);\n\n\t\t\tif (result.done === false) {\n\t\t\t\tresult.value = prepareValue(\n\t\t\t\t\tresult.value,\n\t\t\t\t\ttarget,\n\t\t\t\t\tresult.value,\n\t\t\t\t\tapplyPath\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\treturn iterator;\n};\n"],"names":[],"sourceRoot":""}