(self["webpackChunkjupyter_pixano"] = self["webpackChunkjupyter_pixano"] || []).push([["vendors-node_modules_pixano_core_lib_index_js"],{

/***/ "./node_modules/@pixano/core/lib/event-emitter.js":
/*!********************************************************!*\
  !*** ./node_modules/@pixano/core/lib/event-emitter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicEventTarget": () => (/* binding */ BasicEventTarget)
/* harmony export */ });
class BasicEventTarget {
    constructor() {
        this.listeners = new Map();
    }
    addEventListener(type, listener) {
        const listeners = this.listeners.get(type);
        if (listeners) {
            listeners.push(listener);
        }
        else {
            this.listeners.set(type, [listener]);
        }
    }
    removeEventListener(type, listener) {
        const listeners = this.listeners.get(type);
        if (listeners) {
            const i = listeners.indexOf(listener);
            if (i >= 0) {
                listeners.splice(i, 1);
            }
        }
    }
    dispatchEvent(event) {
        const listeners = this.listeners.get(event.type);
        if (listeners) {
            for (const listener of listeners) {
                listener.call(this, event);
            }
            return !event.defaultPrevented;
        }
        else {
            return true;
        }
    }
}
//# sourceMappingURL=event-emitter.js.map

/***/ }),

/***/ "./node_modules/@pixano/core/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@pixano/core/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observable": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_0__.observable),
/* harmony export */   "ObservableMap": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_0__.ObservableMap),
/* harmony export */   "ObservableSet": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_0__.ObservableSet),
/* harmony export */   "observe": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_0__.observe),
/* harmony export */   "unobserve": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_0__.unobserve),
/* harmony export */   "BasicEventTarget": () => (/* reexport safe */ _event_emitter__WEBPACK_IMPORTED_MODULE_1__.BasicEventTarget),
/* harmony export */   "utils": () => (/* reexport module object */ _utils__WEBPACK_IMPORTED_MODULE_2__)
/* harmony export */ });
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observer */ "./node_modules/@pixano/core/lib/observer.js");
/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-emitter */ "./node_modules/@pixano/core/lib/event-emitter.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/@pixano/core/lib/utils.js");




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@pixano/core/lib/observer.js":
/*!***************************************************!*\
  !*** ./node_modules/@pixano/core/lib/observer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observable": () => (/* binding */ observable),
/* harmony export */   "ObservableSet": () => (/* binding */ ObservableSet),
/* harmony export */   "ObservableMap": () => (/* binding */ ObservableMap),
/* harmony export */   "observe": () => (/* binding */ observe),
/* harmony export */   "unobserve": () => (/* binding */ unobserve)
/* harmony export */ });
/* harmony import */ var on_change__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! on-change */ "./node_modules/on-change/index.js");
/* harmony import */ var on_change__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(on_change__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@pixano/core/lib/utils.js");


const observers = new WeakMap();
const observersOrder = new WeakMap();
function observable(obj) {
    if (observers.has(obj)) {
        return obj;
    }
    const wrapped = on_change__WEBPACK_IMPORTED_MODULE_0___default()(obj, function (path, value) {
        for (const cb of [...observers.get(this)]) {
            cb(path, value);
        }
    });
    observers.set(wrapped, []);
    observersOrder.set(wrapped, []);
    return wrapped;
}
class ObservableSet extends Set {
    constructor(...args) {
        super(...args);
        observers.set(this, []);
        observersOrder.set(this, []);
    }
    add(value) {
        super.add(value);
        for (const cb of [...observers.get(this)]) {
            cb('add', value);
        }
        return this;
    }
    delete(value) {
        const success = super.delete(value);
        for (const cb of [...observers.get(this)]) {
            cb('delete', value);
        }
        return success;
    }
    clear() {
        if (this.size) {
            super.clear();
            for (const cb of [...observers.get(this)]) {
                cb('clear');
            }
        }
    }
    set(values) {
        super.clear();
        values.forEach((v) => {
            super.add(v);
        });
        for (const cb of [...observers.get(this)]) {
            cb('set', values);
        }
    }
}
class ObservableMap extends Map {
    constructor(...args) {
        super(...args);
        observers.set(this, []);
        observersOrder.set(this, []);
    }
    set(key, value) {
        super.set(key, value);
        for (const cb of [...observers.get(this)]) {
            cb('set', value);
        }
        return this;
    }
    delete(key) {
        const success = super.delete(key);
        for (const cb of [...observers.get(this)]) {
            cb('delete', key);
        }
        return success;
    }
    clear() {
        const success = super.clear();
        for (const cb of [...observers.get(this)]) {
            cb('clear');
        }
        return success;
    }
    init(items) {
        super.clear();
        for (const item of items) {
            super.set(item[0], item[1]);
        }
        for (const cb of [...observers.get(this)]) {
            cb('init');
        }
    }
}
function observe(target, observer, order = 10) {
    const _observers = observers.get(target);
    const _observersOrder = observersOrder.get(target);
    if (!_observers || !_observersOrder) {
        throw new Error("object is not observable. "
            + "If you meant to observe its properties, use `observable` first.");
    }
    const i = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.searchSorted)(_observersOrder, order);
    _observers.splice(i, 0, observer);
    _observersOrder.splice(i, 0, order);
    return observer;
}
function unobserve(target, observer) {
    const _observers = observers.get(target);
    const _observersOrder = observersOrder.get(target);
    if (_observers && _observersOrder) {
        const i = _observers.indexOf(observer);
        if (i >= 0) {
            _observers.splice(i, 1);
            _observersOrder.splice(i, 1);
        }
    }
}
//# sourceMappingURL=observer.js.map

/***/ }),

/***/ "./node_modules/on-change/index.js":
/*!*****************************************!*\
  !*** ./node_modules/on-change/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {TARGET, UNSUBSCRIBE} = __webpack_require__(/*! ./lib/constants */ "./node_modules/on-change/lib/constants.js");
const isBuiltin = __webpack_require__(/*! ./lib/is-builtin */ "./node_modules/on-change/lib/is-builtin.js");
const path = __webpack_require__(/*! ./lib/path */ "./node_modules/on-change/lib/path.js");
const isSymbol = __webpack_require__(/*! ./lib/is-symbol */ "./node_modules/on-change/lib/is-symbol.js");
const isIterator = __webpack_require__(/*! ./lib/is-iterator */ "./node_modules/on-change/lib/is-iterator.js");
const wrapIterator = __webpack_require__(/*! ./lib/wrap-iterator */ "./node_modules/on-change/lib/wrap-iterator.js");
const ignoreProperty = __webpack_require__(/*! ./lib/ignore-property */ "./node_modules/on-change/lib/ignore-property.js");
const Cache = __webpack_require__(/*! ./lib/cache */ "./node_modules/on-change/lib/cache.js");
const SmartClone = __webpack_require__(/*! ./lib/smart-clone */ "./node_modules/on-change/lib/smart-clone.js");

const defaultOptions = {
	equals: Object.is,
	isShallow: false,
	pathAsArray: false,
	ignoreSymbols: false,
	ignoreUnderscores: false,
	ignoreDetached: false
};

const onChange = (object, onChange, options = {}) => {
	options = {
		...defaultOptions,
		...options
	};
	const proxyTarget = Symbol('ProxyTarget');
	const {equals, isShallow, ignoreDetached} = options;
	const cache = new Cache(equals);
	const smartClone = new SmartClone();

	const handleChangeOnTarget = (target, property, previous, value) => {
		if (
			!ignoreProperty(cache, options, property) &&
			!(ignoreDetached && cache.isDetached(target, object))
		) {
			handleChange(cache.getPath(target), property, previous, value);
		}
	};

	// eslint-disable-next-line max-params
	const handleChange = (changePath, property, previous, value, name) => {
		if (smartClone.isCloning) {
			smartClone.update(changePath, property, previous);
		} else {
			onChange(path.concat(changePath, property), value, previous, name);
		}
	};

	const getProxyTarget = value => {
		if (value) {
			return value[proxyTarget] || value;
		}

		return value;
	};

	const prepareValue = (value, target, property, basePath) => {
		if (
			isBuiltin.withoutMutableMethods(value) ||
			property === 'constructor' ||
			(isShallow && !SmartClone.isHandledMethod(target, property)) ||
			ignoreProperty(cache, options, property) ||
			cache.isGetInvariant(target, property) ||
			(ignoreDetached && cache.isDetached(target, object))
		) {
			return value;
		}

		if (basePath === undefined) {
			basePath = cache.getPath(target);
		}

		return cache.getProxy(value, path.concat(basePath, property), handler, proxyTarget);
	};

	const handler = {
		get(target, property, receiver) {
			if (isSymbol(property)) {
				if (property === proxyTarget || property === TARGET) {
					return target;
				}

				if (
					property === UNSUBSCRIBE &&
					!cache.isUnsubscribed &&
					cache.getPath(target).length === 0
				) {
					cache.unsubscribe();
					return target;
				}
			}

			const value = isBuiltin.withMutableMethods(target) ?
				Reflect.get(target, property) :
				Reflect.get(target, property, receiver);

			return prepareValue(value, target, property);
		},

		set(target, property, value, receiver) {
			value = getProxyTarget(value);

			const reflectTarget = target[proxyTarget] || target;
			const previous = reflectTarget[property];
			const hasProperty = property in target;

			if (cache.setProperty(reflectTarget, property, value, receiver, previous)) {
				if (!equals(previous, value) || !hasProperty) {
					handleChangeOnTarget(target, property, previous, value);
				}

				return true;
			}

			return false;
		},

		defineProperty(target, property, descriptor) {
			if (!cache.isSameDescriptor(descriptor, target, property)) {
				if (!cache.defineProperty(target, property, descriptor)) {
					return false;
				}

				handleChangeOnTarget(target, property, undefined, descriptor.value);
			}

			return true;
		},

		deleteProperty(target, property) {
			if (!Reflect.has(target, property)) {
				return true;
			}

			const previous = Reflect.get(target, property);

			if (cache.deleteProperty(target, property, previous)) {
				handleChangeOnTarget(target, property, previous);

				return true;
			}

			return false;
		},

		apply(target, thisArg, argumentsList) {
			const thisProxyTarget = thisArg[proxyTarget] || thisArg;

			if (cache.isUnsubscribed) {
				return Reflect.apply(target, thisProxyTarget, argumentsList);
			}

			if (SmartClone.isHandledType(thisProxyTarget)) {
				const applyPath = path.initial(cache.getPath(target));
				const isHandledMethod = SmartClone.isHandledMethod(thisProxyTarget, target.name);

				smartClone.start(thisProxyTarget, applyPath, argumentsList);

				const result = Reflect.apply(
					target,
					smartClone.preferredThisArg(target, thisArg, thisProxyTarget),
					isHandledMethod ?
						argumentsList.map(argument => getProxyTarget(argument)) :
						argumentsList
				);

				const isChanged = smartClone.isChanged(thisProxyTarget, equals, argumentsList);
				const clone = smartClone.stop();

				if (isChanged) {
					if (smartClone.isCloning) {
						handleChange(path.initial(applyPath), path.last(applyPath), clone, thisProxyTarget, target.name);
					} else {
						handleChange(applyPath, '', clone, thisProxyTarget, target.name);
					}
				}

				if (
					(thisArg instanceof Map || thisArg instanceof Set) &&
					isIterator(result)
				) {
					return wrapIterator(result, target, thisArg, applyPath, prepareValue);
				}

				return (SmartClone.isHandledType(result) && isHandledMethod) ?
					cache.getProxy(result, applyPath, handler, proxyTarget) :
					result;
			}

			return Reflect.apply(target, thisArg, argumentsList);
		}
	};

	const proxy = cache.getProxy(object, options.pathAsArray ? [] : '', handler);
	onChange = onChange.bind(proxy);

	return proxy;
};

onChange.target = proxy => proxy[TARGET] || proxy;
onChange.unsubscribe = proxy => proxy[UNSUBSCRIBE] || proxy;

module.exports = onChange;


/***/ }),

/***/ "./node_modules/on-change/lib/cache.js":
/*!*********************************************!*\
  !*** ./node_modules/on-change/lib/cache.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! ./path */ "./node_modules/on-change/lib/path.js");

/**
 * @class Cache
 * @private
 */
class Cache {
	constructor(equals) {
		this._equals = equals;
		this._proxyCache = new WeakMap();
		this._pathCache = new WeakMap();
		this.isUnsubscribed = false;
	}

	_getDescriptorCache() {
		if (this._descriptorCache === undefined) {
			this._descriptorCache = new WeakMap();
		}

		return this._descriptorCache;
	}

	_getProperties(target) {
		const descriptorCache = this._getDescriptorCache();
		let properties = descriptorCache.get(target);

		if (properties === undefined) {
			properties = {};
			descriptorCache.set(target, properties);
		}

		return properties;
	}

	_getOwnPropertyDescriptor(target, property) {
		if (this.isUnsubscribed) {
			return Reflect.getOwnPropertyDescriptor(target, property);
		}

		const properties = this._getProperties(target);
		let descriptor = properties[property];

		if (descriptor === undefined) {
			descriptor = Reflect.getOwnPropertyDescriptor(target, property);
			properties[property] = descriptor;
		}

		return descriptor;
	}

	getProxy(target, path, handler, proxyTarget) {
		if (this.isUnsubscribed) {
			return target;
		}

		this._pathCache.set(target, path);

		let proxy = this._proxyCache.get(target);

		if (proxy === undefined) {
			proxy = target[proxyTarget] === undefined ?
				new Proxy(target, handler) :
				target;

			this._proxyCache.set(target, proxy);
		}

		return proxy;
	}

	getPath(target) {
		return this.isUnsubscribed ? undefined : this._pathCache.get(target);
	}

	isDetached(target, object) {
		path.walk(this.getPath(target), key => {
			if (object) {
				object = object[key];
			}
		});

		return !Object.is(target, object);
	}

	defineProperty(target, property, descriptor) {
		if (!Reflect.defineProperty(target, property, descriptor)) {
			return false;
		}

		if (!this.isUnsubscribed) {
			this._getProperties(target)[property] = descriptor;
		}

		return true;
	}

	setProperty(target, property, value, receiver, previous) { // eslint-disable-line max-params
		if (!this._equals(previous, value) || !(property in target)) {
			const descriptor = this._getOwnPropertyDescriptor(target, property);

			if (descriptor !== undefined && 'set' in descriptor) {
				return Reflect.set(target, property, value, receiver);
			}

			return Reflect.set(target, property, value);
		}

		return true;
	}

	deleteProperty(target, property, previous) {
		if (Reflect.deleteProperty(target, property)) {
			if (!this.isUnsubscribed) {
				const properties = this._getDescriptorCache().get(target);

				if (properties) {
					delete properties[property];
					this._pathCache.delete(previous);
				}
			}

			return true;
		}

		return false;
	}

	isSameDescriptor(a, target, property) {
		const b = this._getOwnPropertyDescriptor(target, property);

		return a !== undefined &&
			b !== undefined &&
			Object.is(a.value, b.value) &&
			(a.writable || false) === (b.writable || false) &&
			(a.enumerable || false) === (b.enumerable || false) &&
			(a.configurable || false) === (b.configurable || false) &&
			a.get === b.get &&
			a.set === b.set;
	}

	isGetInvariant(target, property) {
		const descriptor = this._getOwnPropertyDescriptor(target, property);

		return descriptor !== undefined &&
			descriptor.configurable !== true &&
			descriptor.writable !== true;
	}

	unsubscribe() {
		this._descriptorCache = null;
		this._pathCache = null;
		this._proxyCache = null;
		this.isUnsubscribed = true;
	}
}

module.exports = Cache;


/***/ }),

/***/ "./node_modules/on-change/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/on-change/lib/constants.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = {
	PATH_SEPARATOR: '.',
	TARGET: Symbol('target'),
	UNSUBSCRIBE: Symbol('unsubscribe')
};


/***/ }),

/***/ "./node_modules/on-change/lib/ignore-property.js":
/*!*******************************************************!*\
  !*** ./node_modules/on-change/lib/ignore-property.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isSymbol = __webpack_require__(/*! ./is-symbol */ "./node_modules/on-change/lib/is-symbol.js");

module.exports = (cache, options, property) => {
	return cache.isUnsubscribed ||
		(options.ignoreSymbols && isSymbol(property)) ||
		(options.ignoreUnderscores && property.charAt(0) === '_') ||
		('ignoreKeys' in options && options.ignoreKeys.includes(property));
};


/***/ }),

/***/ "./node_modules/on-change/lib/is-array.js":
/*!************************************************!*\
  !*** ./node_modules/on-change/lib/is-array.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = Array.isArray;


/***/ }),

/***/ "./node_modules/on-change/lib/is-builtin.js":
/*!**************************************************!*\
  !*** ./node_modules/on-change/lib/is-builtin.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


const isBuiltin = {
	withMutableMethods: value => {
		return value instanceof Date ||
			value instanceof Set ||
			value instanceof Map ||
			value instanceof WeakSet ||
			value instanceof WeakMap;
	},
	withoutMutableMethods: value => (typeof value === 'object' ? value === null : typeof value !== 'function') || value instanceof RegExp
};

module.exports = isBuiltin;


/***/ }),

/***/ "./node_modules/on-change/lib/is-iterator.js":
/*!***************************************************!*\
  !*** ./node_modules/on-change/lib/is-iterator.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = value => typeof value === 'object' && typeof value.next === 'function';


/***/ }),

/***/ "./node_modules/on-change/lib/is-object.js":
/*!*************************************************!*\
  !*** ./node_modules/on-change/lib/is-object.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


module.exports = value => toString.call(value) === '[object Object]';


/***/ }),

/***/ "./node_modules/on-change/lib/is-symbol.js":
/*!*************************************************!*\
  !*** ./node_modules/on-change/lib/is-symbol.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


module.exports = value => typeof value === 'symbol';


/***/ }),

/***/ "./node_modules/on-change/lib/path.js":
/*!********************************************!*\
  !*** ./node_modules/on-change/lib/path.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {PATH_SEPARATOR} = __webpack_require__(/*! ./constants */ "./node_modules/on-change/lib/constants.js");
const isArray = __webpack_require__(/*! ./is-array */ "./node_modules/on-change/lib/is-array.js");
const isSymbol = __webpack_require__(/*! ./is-symbol */ "./node_modules/on-change/lib/is-symbol.js");

module.exports = {
	after: (path, subPath) => {
		if (isArray(path)) {
			return path.slice(subPath.length);
		}

		if (subPath === '') {
			return path;
		}

		return path.slice(subPath.length + 1);
	},
	concat: (path, key) => {
		if (isArray(path)) {
			path = path.slice();

			if (key) {
				path.push(key);
			}

			return path;
		}

		if (key && key.toString !== undefined) {
			if (path !== '') {
				path += PATH_SEPARATOR;
			}

			if (isSymbol(key)) {
				return path + key.toString();
			}

			return path + key;
		}

		return path;
	},
	initial: path => {
		if (isArray(path)) {
			return path.slice(0, -1);
		}

		if (path === '') {
			return path;
		}

		const index = path.lastIndexOf(PATH_SEPARATOR);

		if (index === -1) {
			return '';
		}

		return path.slice(0, index);
	},
	last: path => {
		if (isArray(path)) {
			return path[path.length - 1] || '';
		}

		if (path === '') {
			return path;
		}

		const index = path.lastIndexOf(PATH_SEPARATOR);

		if (index === -1) {
			return path;
		}

		return path.slice(index + 1);
	},
	walk: (path, callback) => {
		if (isArray(path)) {
			path.forEach(key => callback(key));
		} else if (path !== '') {
			let position = 0;
			let index = path.indexOf(PATH_SEPARATOR);

			if (index === -1) {
				callback(path);
			} else {
				while (position < path.length) {
					if (index === -1) {
						index = path.length;
					}

					callback(path.slice(position, index));

					position = index + 1;
					index = path.indexOf(PATH_SEPARATOR, position);
				}
			}
		}
	}
};


/***/ }),

/***/ "./node_modules/on-change/lib/smart-clone.js":
/*!***************************************************!*\
  !*** ./node_modules/on-change/lib/smart-clone.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! ./path */ "./node_modules/on-change/lib/path.js");
const isArray = __webpack_require__(/*! ./is-array */ "./node_modules/on-change/lib/is-array.js");
const isBuiltin = __webpack_require__(/*! ./is-builtin */ "./node_modules/on-change/lib/is-builtin.js");
const isObject = __webpack_require__(/*! ./is-object */ "./node_modules/on-change/lib/is-object.js");

const certainChange = () => true;

const shallowEqualArrays = (clone, value) => {
	return clone.length !== value.length || clone.some((item, index) => value[index] !== item);
};

const shallowEqualSets = (clone, value) => {
	if (clone.size !== value.size) {
		return true;
	}

	for (const element of clone) {
		if (!value.has(element)) {
			return true;
		}
	}

	return false;
};

const shallowEqualMaps = (clone, value) => {
	if (clone.size !== value.size) {
		return true;
	}

	let bValue;
	for (const [key, aValue] of clone) {
		bValue = value.get(key);

		if (bValue !== aValue || (bValue === undefined && !value.has(key))) {
			return true;
		}
	}

	return false;
};

const IMMUTABLE_OBJECT_METHODS = new Set([
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'toLocaleString',
	'toString',
	'valueOf'
]);

const IMMUTABLE_ARRAY_METHODS = new Set([
	'concat',
	'includes',
	'indexOf',
	'join',
	'keys',
	'lastIndexOf'
]);

const IMMUTABLE_SET_METHODS = new Set([
	'has',
	'toString'
]);

const IMMUTABLE_MAP_METHODS = new Set([...IMMUTABLE_SET_METHODS].concat(['get']));

const SHALLOW_MUTABLE_ARRAY_METHODS = {
	push: certainChange,
	pop: certainChange,
	shift: certainChange,
	unshift: certainChange,
	copyWithin: shallowEqualArrays,
	reverse: shallowEqualArrays,
	sort: shallowEqualArrays,
	splice: shallowEqualArrays,
	flat: shallowEqualArrays,
	fill: shallowEqualArrays
};

const SHALLOW_MUTABLE_SET_METHODS = {
	add: shallowEqualSets,
	clear: shallowEqualSets,
	delete: shallowEqualSets
};

const COLLECTION_ITERATOR_METHODS = [
	'keys',
	'values',
	'entries'
];

const SHALLOW_MUTABLE_MAP_METHODS = {
	set: shallowEqualMaps,
	clear: shallowEqualMaps,
	delete: shallowEqualMaps
};

const HANDLED_ARRAY_METHODS = new Set([...IMMUTABLE_OBJECT_METHODS]
	.concat([...IMMUTABLE_ARRAY_METHODS])
	.concat(Object.keys(SHALLOW_MUTABLE_ARRAY_METHODS)));

const HANDLED_SET_METHODS = new Set([...IMMUTABLE_SET_METHODS]
	.concat(Object.keys(SHALLOW_MUTABLE_SET_METHODS))
	.concat(COLLECTION_ITERATOR_METHODS));

const HANDLED_MAP_METHODS = new Set([...IMMUTABLE_MAP_METHODS]
	.concat(Object.keys(SHALLOW_MUTABLE_MAP_METHODS))
	.concat(COLLECTION_ITERATOR_METHODS));

class Clone {
	constructor(value, path, argumentsList) {
		this._path = path;
		this._isChanged = false;
		this._clonedCache = new Set();

		if (value instanceof WeakSet) {
			this._weakValue = value.has(argumentsList[0]);
		} else if (value instanceof WeakMap) {
			this._weakValue = value.get(argumentsList[0]);
		} else {
			this.clone = path === undefined ? value : this._shallowClone(value);
		}
	}

	_shallowClone(value) {
		let clone;

		if (isObject(value)) {
			clone = {...value};
		} else if (isArray(value)) {
			clone = [...value];
		} else if (value instanceof Date) {
			clone = new Date(value);
		} else if (value instanceof Set) {
			clone = new Set(value);
		} else if (value instanceof Map) {
			clone = new Map(value);
		}

		this._clonedCache.add(clone);

		return clone;
	}

	preferredThisArg(target, thisArg, thisProxyTarget) {
		const {name} = target;

		if (SmartClone.isHandledMethod(thisProxyTarget, name)) {
			if (isArray(thisProxyTarget)) {
				this._onIsChanged = SHALLOW_MUTABLE_ARRAY_METHODS[name];
			} else if (thisProxyTarget instanceof Set) {
				this._onIsChanged = SHALLOW_MUTABLE_SET_METHODS[name];
			} else if (thisProxyTarget instanceof Map) {
				this._onIsChanged = SHALLOW_MUTABLE_MAP_METHODS[name];
			}

			return thisProxyTarget;
		}

		return thisArg;
	}

	update(fullPath, property, value) {
		if (value !== undefined && property !== 'length') {
			let object = this.clone;

			path.walk(path.after(fullPath, this._path), key => {
				if (!this._clonedCache.has(object[key])) {
					object[key] = this._shallowClone(object[key]);
				}

				object = object[key];
			});

			object[property] = value;
		}

		this._isChanged = true;
	}

	isChanged(value, equals, argumentsList) {
		if (value instanceof Date) {
			return !equals(this.clone.valueOf(), value.valueOf());
		}

		if (value instanceof WeakSet) {
			return this._weakValue !== value.has(argumentsList[0]);
		}

		if (value instanceof WeakMap) {
			return this._weakValue !== value.get(argumentsList[0]);
		}

		return this._onIsChanged === undefined ?
			this._isChanged :
			this._onIsChanged(this.clone, value);
	}
}

class SmartClone {
	constructor() {
		this.stack = [];
	}

	static isHandledType(value) {
		return isObject(value) ||
			isArray(value) ||
			isBuiltin.withMutableMethods(value);
	}

	static isHandledMethod(target, name) {
		if (isObject(target)) {
			return IMMUTABLE_OBJECT_METHODS.has(name);
		}

		if (isArray(target)) {
			return HANDLED_ARRAY_METHODS.has(name);
		}

		if (target instanceof Set) {
			return HANDLED_SET_METHODS.has(name);
		}

		if (target instanceof Map) {
			return HANDLED_MAP_METHODS.has(name);
		}

		return isBuiltin.withMutableMethods(target);
	}

	get isCloning() {
		return this.stack.length !== 0;
	}

	start(value, path, argumentsList) {
		this.stack.push(new Clone(value, path, argumentsList));
	}

	update(fullPath, property, value) {
		this.stack[this.stack.length - 1].update(fullPath, property, value);
	}

	preferredThisArg(target, thisArg, thisProxyTarget) {
		return this.stack[this.stack.length - 1].preferredThisArg(target, thisArg, thisProxyTarget);
	}

	isChanged(isMutable, value, equals, argumentsList) {
		return this.stack[this.stack.length - 1].isChanged(isMutable, value, equals, argumentsList);
	}

	stop() {
		return this.stack.pop().clone;
	}
}

module.exports = SmartClone;


/***/ }),

/***/ "./node_modules/on-change/lib/wrap-iterator.js":
/*!*****************************************************!*\
  !*** ./node_modules/on-change/lib/wrap-iterator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {TARGET} = __webpack_require__(/*! ./constants */ "./node_modules/on-change/lib/constants.js");

// eslint-disable-next-line max-params
module.exports = (iterator, target, thisArg, applyPath, prepareValue) => {
	const originalNext = iterator.next;

	if (target.name === 'entries') {
		iterator.next = function () {
			const result = originalNext.call(this);

			if (result.done === false) {
				result.value[0] = prepareValue(
					result.value[0],
					target,
					result.value[0],
					applyPath
				);
				result.value[1] = prepareValue(
					result.value[1],
					target,
					result.value[0],
					applyPath
				);
			}

			return result;
		};
	} else if (target.name === 'values') {
		const keyIterator = thisArg[TARGET].keys();

		iterator.next = function () {
			const result = originalNext.call(this);

			if (result.done === false) {
				result.value = prepareValue(
					result.value,
					target,
					keyIterator.next().value,
					applyPath
				);
			}

			return result;
		};
	} else {
		iterator.next = function () {
			const result = originalNext.call(this);

			if (result.done === false) {
				result.value = prepareValue(
					result.value,
					target,
					result.value,
					applyPath
				);
			}

			return result;
		};
	}

	return iterator;
};


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_pixano_core_lib_index_js.83595bd0d3a171c360f5.js.map