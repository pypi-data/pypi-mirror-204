#!/usr/bin/env python3
# Generated by "pythonizer -aM PyModules/Env.pm" v1.028 run by SNOOPYJC on Mon Feb 27 10:23:41 2023
__author__ = """Joe Cool"""
__email__ = "snoopyjc@gmail.com"
__version__ = "1.028"
import builtins, os, perllib, re, types

_bn = lambda s: "" if s is None else s
_pb = lambda b: 1 if b else ""
_str = lambda s: "" if s is None else str(s)
import Config as _Config

# SNOOPYJC perllib.import_(globals(), "Tie/Array")
# SNOOPYJC perllib.import_(globals(), "Tie/Array")
perllib.init_package("Env", is_class=True)
perllib.init_package("Env.Array_", is_class=True)
# SNOOPYJC perllib.init_package("Env.Array_.VMS", is_class=True)


def SPLICE(*_args, wantarray=False):
    _args = list(_args)
    global sep

    result = ""
    result_a = perllib.Array()
    self = _args.pop(0) if _args else None
    self = self[0]          # SNOOPYJC
    offset = _args.pop(0) if _args else None
    length = _args.pop(0) if _args else None
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    if wantarray:
        result_a = perllib.Array(
            perllib.splice(temp, perllib.int_(offset), perllib.int_(length), *_args)
        )
        os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
        return result_a
    else:
        result = perllib.splice_s(temp, perllib.int_(offset), perllib.int_(length), *_args)
        os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
        return result


Env.Array_.SPLICE = lambda *_args, **_kwargs: perllib.tie_call(SPLICE, _args, _kwargs)

######################################################################


def SHIFT(*_args):
    global sep
    [self] = perllib.list_of_n(_args, 1)
    self = self[0]          # SNOOPYJC
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    result = temp.pop(0) if temp else None
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return result


Env.Array_.SHIFT = lambda *_args, **_kwargs: perllib.tie_call(SHIFT, _args, _kwargs)


def UNSHIFT(*_args):
    _args = list(_args)
    global sep
    self = _args.pop(0) if _args else None
    self = self[0]          # SNOOPYJC
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    result = temp[0:0] = _args
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return result


Env.Array_.UNSHIFT = lambda *_args, **_kwargs: perllib.tie_call(UNSHIFT, _args, _kwargs)


def POP(*_args):
    global sep
    [self] = perllib.list_of_n(_args, 1)
    self = self[0]          # SNOOPYJC
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    result = temp.pop() if temp else None
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return result


Env.Array_.POP = lambda *_args, **_kwargs: perllib.tie_call(POP, _args, _kwargs)


def PUSH(*_args):
    _args = list(_args)
    global sep
    self = _args.pop(0) if _args else None
    self = self[0]          # SNOOPYJC
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    temp.extend(_args)
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return len(temp)


Env.Array_.PUSH = lambda *_args, **_kwargs: perllib.tie_call(PUSH, _args, _kwargs)


# SNOOPYJC def DELETE(*_args):
# SNOOPYJC     global sep
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC Env.Array_.VMS.DELETE = lambda *_args, **_kwargs: perllib.tie_call(DELETE, _args, _kwargs)
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC def EXISTS(*_args):
# SNOOPYJC     [self, index] = perllib.list_of_n(_args, 2)
# SNOOPYJC     return _pb(perllib.num(index) < perllib.num(self.FETCHSIZE()))
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC Env.Array_.VMS.EXISTS = lambda *_args, **_kwargs: perllib.tie_call(EXISTS, _args, _kwargs)


def CLEAR(*_args):
    [self] = perllib.list_of_n(_args, 1)
    os.environ[_str(self)] = ""
    return os.environ.get(_str(self))


Env.Array_.CLEAR = lambda *_args, **_kwargs: perllib.tie_call(CLEAR, _args, _kwargs)


def STORESIZE(*_args):
    global sep
    [self, size] = perllib.list_of_n(_args, 2)
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    perllib.set_last_ndx(temp, perllib.num(size) - 1)
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return os.environ.get(_str(self))


Env.Array_.STORESIZE = lambda *_args, **_kwargs: perllib.tie_call(STORESIZE, _args, _kwargs)


# SNOOPYJC def FETCHSIZE(*_args):
# SNOOPYJC     [self] = perllib.list_of_n(_args, 1)
# SNOOPYJC     i = 0
# SNOOPYJC     while i < 127 and os.environ.get(_str(self) + ";" + _str(i)) is not None:
# SNOOPYJC         i += 1
# SNOOPYJC 
# SNOOPYJC     return i
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC Env.Array_.VMS.FETCHSIZE = lambda *_args, **_kwargs: perllib.tie_call(FETCHSIZE, _args, _kwargs)
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC def TIEARRAY(*_args):
# SNOOPYJC     return perllib.add_tie_methods(perllib.bless((_args[1]), "Env.Array_.VMS"))
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC Env.Array_.VMS.TIEARRAY = types.MethodType(TIEARRAY, Env.Array_.VMS)


def STORE(*_args):
    global sep
    [self, index, value] = perllib.list_of_n(_args, 3)
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    temp[perllib.int_(index)] = value
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return value


STOREa = STORE
Env.Array_.STORE = lambda *_args, **_kwargs: perllib.tie_call(STOREa, _args, _kwargs)


# SNOOPYJC def FETCH(*_args):
# SNOOPYJC     global sep
# SNOOPYJC     [self, index] = perllib.list_of_n(_args, 2)
# SNOOPYJC     return os.environ.get(_str(self) + ";" + _str(index))
# SNOOPYJC 
# SNOOPYJC 
# SNOOPYJC Env.Array_.VMS.FETCH = lambda *_args, **_kwargs: perllib.tie_call(FETCH, _args, _kwargs)


def TIESCALAR(*_args):
    # SNOOPYJC return perllib.add_tie_methods(perllib.bless((_args[1]), "Env"))
    return perllib.add_tie_methods(perllib.bless([_args[1]], "Env"))    # SNOOPYJC


Env.TIESCALAR = types.MethodType(TIESCALAR, Env)


def import_(*_args):
    _args = list(_args)
    global _d
    [callpack] = perllib.list_of_n(perllib.caller(0), 1)
    pack = _args.pop(0) if _args else None
    vars_ = perllib.Array(
        list(
            filter(
                lambda _d: re.search(rf"^[\$@]?[A-Za-z_]\w*$", _str(_d)),
                perllib.make_list(_args if _args else os.environ.keys()),
            )
        )
    )
    if not vars_:
        return

    vars_ = perllib.Array(
        perllib.flatten(
            map(lambda _d: _d if re.search(rf"^[\$@]", _str(_d)) else "$" + _str(_d), vars_)
        )
    )

    # eval "package $callpack; use vars qw(" . join(' ', @vars) . ")";
    # die $@ if $@;
    for _d in vars_:
        [type_, name] = perllib.list_of_n(
            ((_m := re.search(rf"^([\$@])(.*)$", _str(_d))), _m.groups() if _m else [])[1], 2
        )
        if _str(type_) == "$":
            perllib.store_perl_meta(f"{_bn(callpack)}::{_bn(name)}" + "_v", Env.TIESCALAR(name))
        else:
            # SNOOPYJC if perllib.os_name() == "VMS":
            # SNOOPYJC     perllib.store_perl_global(
            # SNOOPYJC         f"{_bn(callpack)}::{_bn(name)}" + "_a", Env.Array_.VMS.TIEARRAY(name)
            # SNOOPYJC     )
            # SNOOPYJC else:
                perllib.store_perl_global(
                    f"{_bn(callpack)}::{_bn(name)}" + "_a", Env.Array_.TIEARRAY(name)
                )


Env.import_ = import_

_d = ""
sep = None

builtins.__PACKAGE__ = "Env"

Env.VERSION_v = "1.05"

"""
=head1 NAME

Env - perl module that imports environment variables as scalars or arrays

=head1 SYNOPSIS

    use Env;
    use Env qw(PATH HOME TERM);
    use Env qw($SHELL @LD_LIBRARY_PATH);

=head1 DESCRIPTION

Perl maintains environment variables in a special hash named C<%ENV>.  For
when this access method is inconvenient, the Perl module C<Env> allows
environment variables to be treated as scalar or array variables.

The C<Env::import()> function ties environment variables with suitable
names to global Perl variables with the same names.  By default it
ties all existing environment variables (C<keys %ENV>) to scalars.  If
the C<import> function receives arguments, it takes them to be a list of
variables to tie; it's okay if they don't yet exist. The scalar type
prefix '$' is inferred for any element of this list not prefixed by '$'
or '@'. Arrays are implemented in terms of C<split> and C<join>, using
C<$Config::Config{path_sep}> as the delimiter.

After an environment variable is tied, merely use it like a normal variable.
You may access its value 

    @path = split(/:/, $PATH);
    print join("\n", @LD_LIBRARY_PATH), "\n";

or modify it

    $PATH .= ":/any/path";
    push @LD_LIBRARY_PATH, $dir;

however you'd like. Bear in mind, however, that each access to a tied array
variable requires splitting the environment variable's string anew.

The code:

    use Env qw(@PATH);
    push @PATH, '/any/path';

is almost equivalent to:

    use Env qw(PATH);
    $PATH .= ":/any/path";

except that if C<$ENV{PATH}> started out empty, the second approach leaves
it with the (odd) value "C<:/any/path>", but the first approach leaves it with
"C</any/path>".

To remove a tied environment variable from
the environment, assign it the undefined value

    undef $PATH;
    undef @LD_LIBRARY_PATH;

=head1 LIMITATIONS

On VMS systems, arrays tied to environment variables are read-only. Attempting
to change anything will cause a warning.

=head1 AUTHOR

Chip Salzenberg E<lt>F<chip@fin.uucp>E<gt>
and
Gregor N. Purdy E<lt>F<gregor@focusresearch.com>E<gt>

=cut
"""


def FETCH(*_args):
    global sep
    [self] = perllib.list_of_n(_args, 1)
    self = self[0]      # SNOOPYJC
    # SNOOPYJC return os.environ[_str(self)]
    return os.environ.get(_str(self))       # SNOOPYJC: issue s303


FETCH0 = FETCH
Env.FETCH = lambda *_args, **_kwargs: perllib.tie_call(FETCH0, _args, _kwargs)
#Env.FETCH = functools.partial(lambda FETCH, *_args, **_kwargs: perllib.tie_call(FETCH, _args, _kwargs), FETCH=FETCH)
#Env.FETCH = functools.partial(lambda func, *_args, **_kwargs: perllib.tie_call(func, _args, _kwargs), FETCH)
#Env.FETCH = functools.partial(perllib.tie_call, FETCH)


def STORE(*_args):
    global sep
    [self, value] = perllib.list_of_n(_args, 2)
    self = self[0]      # SNOOPYJC
    if value is not None:
        os.environ[_str(self)] = _str(value)
        return os.environ.get(_str(self))
    else:
        return os.environ.pop(_str(self), None)


STORE0 = STORE
Env.STORE = lambda *_args, **_kwargs: perllib.tie_call(STORE0, _args, _kwargs)
#Env.STORE = functools.partial(lambda func, *_args, **_kwargs: perllib.tie_call(func, _args, _kwargs), STORE)
#Env.STORE = functools.partial(perllib.tie_call, STORE)

######################################################################

# SNOOPYJC builtins.__PACKAGE__ = "Env.Array"
builtins.__PACKAGE__ = "Env.Array_"     # SNOOPYJC

# SNOOPYJC Env.Array_.ISA_a = "Tie::Array".split()

sep = Config.Config_h.get("path_sep")


def TIEARRAY(*_args):
    # SNOOPYJC return perllib.add_tie_methods(perllib.bless((_args[1]), "Env.Array_"))
    return perllib.add_tie_methods(perllib.bless([_args[1]], "Env.Array_"))     # SNOOPYJC: Can't bless a scalar


Env.Array_.TIEARRAY = types.MethodType(TIEARRAY, Env.Array_)


def FETCHSIZE(*_args):
    [self] = perllib.list_of_n(_args, 1)
    self = self[0]      # SNOOPYJC
    # SNOOPYJC return 1 + len(
    return 1 + (            # SNOOPYJC
        len(
            [
                _m[0]
                for _m in (
                    re.finditer(
                        re.compile(rf"{perllib.quotemeta(_bn(sep))}"),
                        _str(os.environ.get(_str(self))),
                    )
                )
            ]
        )
    )


Env.Array_.FETCHSIZE = lambda *_args, **_kwargs: perllib.tie_call(FETCHSIZE, _args, _kwargs)


def FETCH(*_args):
    global sep
    [self, index] = perllib.list_of_n(_args, 2)
    self = self[0]      # SNOOPYJC
    return (perllib.split(_str(sep), _str(os.environ.get(_str(self)))))[perllib.int_(index)]


FETCHa = FETCH
Env.Array_.FETCH = lambda *_args, **_kwargs: perllib.tie_call(FETCHa, _args, _kwargs)
#Env.Array_.FETCH = functools.partial(lambda FETCH, *_args, **_kwargs: perllib.tie_call(FETCH, _args, _kwargs), FETCH=FETCH)
#Env.Array_.FETCH = functools.partial(lambda FETCH, *_args, **_kwargs: perllib.tie_call(FETCH, _args, _kwargs), FETCH=FETCH)


def EXISTS(*_args):
    [self, index] = perllib.list_of_n(_args, 2)
    return _pb(perllib.num(index) < perllib.num(self.FETCHSIZE()))


Env.Array_.EXISTS = lambda *_args, **_kwargs: perllib.tie_call(EXISTS, _args, _kwargs)


def DELETE(*_args):
    global sep
    [self, index] = perllib.list_of_n(_args, 2)
    self = self[0]      # SNOOPYJC
    temp = perllib.Array(perllib.split(_str(sep), _str(os.environ.get(_str(self)))))
    value = perllib.splice_s(
        temp,
        perllib.int_(index),
        1,
    )
    os.environ[_str(self)] = (_str(sep)).join(map(_str, temp))
    return value


Env.Array_.DELETE = lambda *_args, **_kwargs: perllib.tie_call(DELETE, _args, _kwargs)
# SNOOPYJC builtins.__PACKAGE__ = "Env.Array.VMS"

# SNOOPYJC Env.Array_.VMS.ISA_a = "Tie::Array".split()
