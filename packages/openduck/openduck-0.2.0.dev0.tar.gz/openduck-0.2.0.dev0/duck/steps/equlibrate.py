import simtk.openmm as mm
import simtk.openmm.app as app
import simtk.unit as u
import parmed
from parmed.openmm import NetCDFReporter
import pickle
from duck.utils import duck_stuff
from duck.utils import cal_ints

def do_equlibrate(force_constant_equilibrate=1.0,gpu_id=0, keyInteraction=None):
    """
    Function to perform minimization, heating, and density equilibration simulations of the protein-ligand complex in openMM.

    Parameters:
    -----------
    force_constant_equilibrate : float, optional
        The force constant value for the harmonic positional restraints applied to heavy atoms during equilibration.
    gpu_id : int, optional
        The ID of the GPU device to be used for simulations. If None, the CPU platform will be used.
    keyInteraction : str, optional
        The name of the interaction type to be used for restraining the ligand-chunk distance during equilibration.

    Returns:
    --------
    list
        A list with a single string element representing the path to the checkpoint file generated by the function.
    """
    # Find the interations
    if not keyInteraction:
        keyInteraction = cal_ints.find_interaction()
    # Platform definition
    platformProperties = {}
    if gpu_id != None:
        platform = mm.Platform_getPlatformByName("CUDA")
        platformProperties["CudaPrecision"] = "double"
        platformProperties["DeviceIndex"] = str(gpu_id)
    else:
        platform = mm.Platform_getPlatformByName("CPU")
    platformProperties["DeterministicForces"] = 'true'
    print("loading pickle")
    pickle_in=open('complex_system.pickle', 'rb')
    combined_pmd = pickle.load(pickle_in)[0]
    combined_pmd.symmetry=None
    pickle_in.close()
    ##################
    ##################
    #  Minimisation  #
    ##################
    ##################
    print('Minimising...')
    # Define system
    system = combined_pmd.createSystem(nonbondedMethod=app.PME, nonbondedCutoff=9*u.angstrom)
    # Get indexes of heavy atoms in chunk
    Chunk_Heavy_Atoms = duck_stuff.getHeavyAtomsInSystem(combined_pmd)
    # Apply force on all havy atoms of chunk
    duck_stuff.applyHarmonicPositionalRestraints(system, force_constant_equilibrate, combined_pmd.positions, Chunk_Heavy_Atoms)
    # Integrator
    integrator = mm.VerletIntegrator(1*u.femtosecond)
    # Define Simulation
    simulation = app.Simulation(combined_pmd.topology, system, integrator, platform,platformProperties)
    simulation.context.setPositions(combined_pmd.positions)
    print(simulation.context.getPlatform().getName())
    for key in simulation.context.getPlatform().getPropertyNames():
        print(key, simulation.context.getPlatform().getPropertyValue(simulation.context, key))
    # Minimizing energy
    simulation.minimizeEnergy(maxIterations=1000)
    # Saving minimised positions
    positions = simulation.context.getState(getPositions=True).getPositions()
    app.PDBFile.writeFile(simulation.topology, positions, open('minimisation.pdb', 'w'))
    ##########################
    ##########################
    # Equlibration - heating #
    ##########################
    ##########################
    #new minimised positions, however using old restraints
    # Define new system
    system = combined_pmd.createSystem(nonbondedMethod=app.PME, nonbondedCutoff=9*u.angstrom, constraints=app.HBonds, hydrogenMass=None)
    # Apply force on all havy atoms of chunk and apply restraint for the ligand-chunk distance
    duck_stuff.applyHarmonicPositionalRestraints(system, force_constant_equilibrate, combined_pmd.positions, Chunk_Heavy_Atoms)
    duck_stuff.applyLigandChunkRestraint(system, force_constant_equilibrate, 10.0, 2*u.angstrom, 3*u.angstrom, 4*u.angstrom, keyInteraction)
    # Intergator
    integrator = mm.LangevinIntegrator(300*u.kelvin, 4/u.picosecond, 0.002*u.picosecond)
    # Define Simulation
    simulation = app.Simulation(combined_pmd.topology, system, integrator, platform,platformProperties)
    simulation.context.setPositions(positions) #changing coordintes to minimized
    # Reporters
    simulation.reporters.append(app.StateDataReporter("heating.csv", 1000, time=True, potentialEnergy=True, temperature=True, density=True, remainingTime=True, speed=True, totalSteps=50000))
    simulation.reporters.append(app.DCDReporter("heating.dcd", 1000))
    # Heating the system
    print("Heating ... ")
    simulation.step(50000) # 0.01 ns
    # Save the positions and velocities
    positions = simulation.context.getState(getPositions=True).getPositions()
    velocities = simulation.context.getState(getVelocities=True).getVelocities()
    app.PDBFile.writeFile(simulation.topology, positions, open('heating_final.pdb', 'w'))
    #clear reporters
    simulation.reporters = []
    ##########################
    ##########################
    # Equlibration - density #
    ##########################
    ##########################
    simulation = duck_stuff.setUpNPTEquilibration(system, combined_pmd,platform, platformProperties, positions, velocities)
    # Reporters
    simulation.reporters.append(app.StateDataReporter("density.csv", 1000, time=True, potentialEnergy=True, temperature=True, density=True, remainingTime=True, speed=True, totalSteps=50000))
    simulation.reporters.append(NetCDFReporter("3_eq.nc", 1000, vels=True))
    # Correcting the density
    print("Correcting density")
    simulation.step(50000) # 0.01 ns
    # Save the positions and velocities
    positions = simulation.context.getState(getPositions=True).getPositions()
    velocities = simulation.context.getState(getVelocities=True).getVelocities()
    app.PDBFile.writeFile(simulation.topology, positions, open('density_final.pdb', 'w'))

    checkpoint = 'equil.chk'
    simulation.saveCheckpoint(checkpoint)


    return [checkpoint]

def equilibrate_from_amber_prep(interaction, prmtop_file, inpcrd_file, chunk,  gpu_id, force_constant_eq=1.0):
    from duck.utils.check_system import check_if_equlibrated
    # Load the prepared system:
    c_pm = parmed.load_file(prmtop_file, inpcrd_file)
    # Find the interations
    keyInteraction = cal_ints.find_interaction_amber_input(combined_pmd=c_pm, chunk_file=chunk, res_atom=interaction)
    # Platform definition
    platformProperties = {}
    if gpu_id != None:
        platform = mm.Platform_getPlatformByName("CUDA")
        platformProperties["CudaPrecision"] = "double"
    else:
        platform = mm.Platform_getPlatformByName("CPU")
    platformProperties["DeterministicForces"] = 'true'

    complex = "./complex_system.pickle"
    pickle_out = open(complex, "wb")
    pickle.dump([c_pm], pickle_out)
    pickle_out.close()

    with open('complex_system.pickle', 'rb') as f:
        p = pickle.load(f) + keyInteraction
    with open('complex_system.pickle', 'wb') as f:
        pickle.dump(p, f, protocol=pickle.HIGHEST_PROTOCOL)

    checkpoint = do_equlibrate(keyInteraction=keyInteraction, force_constant_equilibrate=force_constant_eq, gpu_id=gpu_id)
    if not check_if_equlibrated("density.csv", 1):
        raise EquilibrationError("System is not equilibrated.")
    return checkpoint
if __name__ == "__main__":
    do_equlibrate()
