
from cd2t.types.base import BaseDataType
from cd2t.results import AutogenerationInfo, FindingsList, ValidationFinding
from cd2t.RunTimeEnv import RunTimeEnv
from cd2t.schema import SchemaError


class Bool(BaseDataType):
    type = 'bool'
    path_symbol = '!'
    matching_classes = [bool]
    options = [
        # option_name, required, class
        ('autogenerate', False, bool, False),
        ('autogenerate_default', False, bool, None),
        ('allowed_value', False, bool, None)
    ]

    def __init__(self) -> None:
        super().__init__()
        self.autogenerate = False
        self.autogenerate_default = None
        self.allowed_value = None
    
    def verify_options(self, path: str):
        if self.autogenerate:
            if self.autogenerate_default is None:
                raise SchemaError("'autogenerate_default' is required, if autogenerate is enabled", path)
            elif self.allowed_value is not None and self.autogenerate_default != self.allowed_value:
                raise SchemaError("'allowed_value' and 'autogenerate_default' must be equal", path)
 
    def verify_data(self, data :any, path :str, RTE :RunTimeEnv) -> FindingsList:
        FL = FindingsList()
        if self.allowed_value is not None and data != self.allowed_value:
            FL.append(ValidationFinding(path=path, message='Value is not allowed'))
        return FL
    
    def autogenerate_data(self, data :any, path :str, RTE :RunTimeEnv):
        FL = FindingsList()
        if data is not None or not self.autogenerate:
            return data, FL
        new_value = self.autogenerate_default
        FL.append(AutogenerationInfo(
                    path=path,
                    message='Autogenerated value is %s' % str(new_value)))
        return new_value, FL
    