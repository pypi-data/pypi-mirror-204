# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['cjdb',
 'cjdb.model',
 'cjdb.model.sqlalchemy_models',
 'cjdb.modules',
 'cjdb.resources']

package_data = \
{'': ['*']}

install_requires = \
['cjio>=0.8.1,<0.9.0',
 'geoalchemy2>=0.13.1,<0.14.0',
 'numpy>=1.24.2,<2.0.0',
 'psycopg2-binary>=2.9.6,<3.0.0',
 'pyproj>=3.5.0,<4.0.0',
 'requests>=2.28.2,<3.0.0',
 'shapely>=2.0.1,<3.0.0']

entry_points = \
{'console_scripts': ['cjdb = cjdb.main:main']}

setup_kwargs = {
    'name': 'cjdb',
    'version': '1.2.0',
    'description': 'CJDB is a tool that enables CityJSON integration with a PostgreSQL database',
    'long_description': '# cjdb\n[![MIT badge](https://img.shields.io/pypi/l/cjdb)](LICENSE) &nbsp; [![PyPI](https://img.shields.io/pypi/v/cjdb)](https://pypi.org/project/cjdb)\n\n`cjdb` is a Python based importer of CityJSONL files to a PostgreSQL database. It requires the [PostGIS](https://postgis.net/) extension.\n\nAuthors: Cynthia Cai, Lan Yan, Yitong Xia, Chris Poon, Siebren Meines, Leon Powalka\n\nMaintainer: Gina Stavropoulou\n\n## Table of Contents  \n### [1.Data model](#1-data-model)\n### [2.Installation](#2-installation)\n- [Using pip](#using-pip)\n- [Using Docker](#using-docker)\n### [3.Usage](#3-usage)\n- [CLI](#cli)\n- [Quickstart](#quickstart)\n- [Basic Queries](#basic-queries)\n### [4.Local development](#4-local-development)\n- [Install and Build](#install-and-build)\n- [Testing](#testing)\n### [5.Explanation](#5-explanation)\n - [Model assumptions](#model-assumptions)\n - [What is a City Model?](#what-is-a-city-model)\n - [Types of input](#types-of-input)\n - [Coordinate Reference Systems](#coordinate-reference-systems)\n - [3D reprojections](#3d-reprojections)\n - [CityJSON Extensions](#cityjson-extensions)\n - [CityJSON GeometryTemplate](#cityjson-geometrytemplate)\n - [Data validation](#data-validation)\n - [Repeated object IDs](#repeated-object-ids)\n---\n## 1. Data model\nFor the underlying data model see [cjdb/model/README.md](cjdb/model/README.md)\n\n\n## 2. Installation\n### Using pip\n```bash\npip install cjdb\n```\nIt is recommended to install it in an isolated environment, because of fragile external library dependencies for CQL filter parsing.\n\n### Using docker\nBuild:\n```bash\ndocker build -t cjdb:latest .\n```\n\nRun:\n```bash\ndocker run --rm -it cjdb cjdb --help\n```\n\nTo import some files, the `-v` option is needed to mount our local file directory in the container:\n```bash\ndocker run -v {MYDIRECTORY}:/data --rm -it --network=host cjdb cjdb -H localhost -U postgres -d postgres -W postgres /data/5870_ext.jsonl \n```\n## 3. Usage <a name="usage"></a>\n\n### CLI <a name="cli"></a>\n\n```bash\ncj2pgsql [-h] [-H DB_HOST] [-p DB_PORT] -U DB_USER [-W DB_PASSWORD] -d DB_NAME [-s DB_SCHEMA] [-I TARGET_SRID][-x INDEXED_ATTRIBUTES] [-px PARTIAL_INDEXED_ATTRIBUTES] [-g] [-a | -o] [-e | -u] [file_or_directory]\n```\n#### Positional Arguments\nfile_or_directory\nSource CityJSONL file or a directory with CityJSONL files. STDIN if not specified. If specifying a directory, all the *.jsonl files inside of it will be imported.\n\nDefault: “stdin”\n\n#### Named Arguments\n`-I, --srid`\nTarget coordinate system SRID. All 3D and 2D geometries will be reprojected.\n\n`-x, --attr-index`\nCityObject attribute to be indexed using a btree index. Can be specified multiple times, for each attribute once.\n\nDefault: []\n\n`-px, --partial-attr-index`\nCityObject attribute to be indexed using a btree partial index. Can be specified multiple times, for each attribute once. This index indexes on a condition ‘where {\n                {ATTR_NAME\n                }\n        } is not null’. This means that it saves space and improves query performance when the attribute is not present for all imported CityObjects.\n\nDefault: []\n\n`-g, --ignore-repeated-file`\nIgnore repeated file names warning when importing. By default, the importer will send out warnings if a specific file has already been imported.\n\nDefault: False\n\n`-a, --append`\nRun in append mode (as opposed to default create mode). This assumes the database structure exists already and new data is to be appended.\n\nDefault: False\n\n`-o, --overwrite`\nOverwrite the data that is currently in the database schema. Warning: this causes the loss of what was imported before to the database schema.\n\nDefault: False\n\n`-u, --update-existing`\nCheck if the object with given ID exists before inserting, and update it if it does. The old object will be updated with the new object’s properties.\n\nDefault: False\n\n#### Database connection arguments\n`-H, --host`\nPostgreSQL database host\n\nDefault: “localhost”\n\n`-p, --port`\nPostgreSQL database port\n\nDefault: 5432\n\n`-U, --user`\nPostgreSQL database user name\n\n`-W, --password`\nPostgreSQL database user password\n\n`-d, --database`\nPostgreSQL database name\n\n`-s, --schema`\nTarget database schema\n\nDefault: “public”\n\n### Quickstart\n\nSample CityJSON data can be downloaded from [3DBAG download service](https://3dbag.nl/nl/download?tid=901). Then, having the CityJSON file, a combination of [cjio](https://github.com/cityjson/cjio) (external CityJSON processing library) and cjdb is needed to import it to a specified schema in a database. \n\n1. Convert CityJSON to CityJSONL\n\n```bash\ncjio --suppress_msg tile_901.json export jsonl tile_901.jsonl \n```\n\n2. Create a new database\n\n  - [how to create a new database](https://postgis.net/workshops/postgis-intro/creating_db.html)\n\n3. Import CityJSONL to the database\n```bash\nPGPASSWORD=postgres cjdb -H localhost -U postgres -d postgres -s cjdb -o tile_901.jsonl   \n```\n\n**Alternatively steps 1 and 2 in a single command:**\n\n```bash\ncjio --suppress_msg tile_901.json export jsonl stdout | cjdb -H localhost -U postgres -d postgres -s cjdb -o\n```\n\nThe metadata and the objects can then be found in the tables in the specified schema (`cjdb` in this example).\n\n\nPassword can be specified in the `PGPASSWORD` environment variable. If not specified, the app will prompt for the password.\n\n\n### Basic Queries\n\n- Query an object with a specific id:\n```SQL\nSELECT * FROM cjdb.cj_object\nWHERE object_id = \'NL.IMBAG.Pand.0503100000000334\';\n```\n\n- Query a building with a specific child\n```SQL\nSELECT o.* FROM cjdb.family f\nINNER JOIN cjdb.cj_object o ON o.object_id = f.parent_id\nWHERE f.child_id = \'NL.IMBAG.Pand.0503100000000334-0\'\n```\n\n- Query all buildings within a bounding box\n```SQL\nSELECT * FROM cjdb.cj_object\nWHERE type = \'Building\'\nAND ST_Contains(ST_MakeEnvelope(81900.00, 446850.00, 81930.00, 446900.00, 7415), ground_geometry)\nORDER BY id ASC;\n```\n\n- Query the building intersecting with a point\n```SQL\nSELECT * FROM cjdb.cj_object\nWHERE ground_geometry && ST_MakePoint(81915.00, 446850.00)\nAND type = \'Building\'\nORDER BY object_id ASC;\n```\n\n- Query all objects with a slanted roof\n```SQL\nSELECT * FROM cjdb.cj_object\nWHERE (attributes->\'dak_type\')::varchar = \'"slanted"\'\nORDER BY id ASC;\n```\n\n- Query all the buildings made after 2000:\n```SQL\nSELECT * FROM cjdb.cj_object\nWHERE (attributes->\'oorspronkelijkbouwjaar\')::int > 2000\nAND type = \'Building\'\nORDER BY id ASC;\n```\n\n- Query all objects with LOD 1.2\n\n```SQL\nSELECT * FROM cjdb.cj_object\nWHERE geometry::jsonb @> \'[{"lod": 1.2}]\'::jsonb\n```\n\n## 4. Local development\n\n### Install and Build\nMake sure [poetry](https://python-poetry.org/docs/) is installed and the [creation of virtual environments within the project is allowed](\nhttps://python-poetry.org/docs/configuration/#virtualenvsin-project):\n\n```\npoetry config virtualenvs.in-project true\n```\n\nThen, to create a local environment with all the necessary dependencies, run from the repository root:\n```bash\npoetry install\n```\n\nTo activate the env:\n```bash\nsource .venv/bin/activate \n```\n\nThen you can run the CLI command:\n```bash\ncjdb --help\n```\n\nEvery time you make some changed to the package you can run `poetry install` to reinstall.\n\n\n### Testing\nIn onder to run the tests you need to have [PostgreSQL](https://www.postgresql.org/download/) installed. Then you can run:\n\n```bash\npytest -v\n```\n\n## 5. Explanation\n---\n### Model assumptions\nThe `cjdb` importer loads the data in accordance with a specific data model.\n\nModel documentation:\n [model/README](model/README.md)\n\n#### Indexes\nSome indexes are created by default (refer to [model/README](model/README.md)).\n\nAdditionally, the user can specify which CityObject attributes are to be indexed with the `-x/--attr-index` or `-px/--partial-attr-index` flag, we recommend doing this if several queries are made on specific attributes. \nThe second option uses a partial index with a `not null` condition on the attribute. This saves disk space when indexing an attribute that is not present among all the imported CityObjects. \nThis is often the case with CityJSON, because in a single dataset there can be different object types, with different attributes.\n\n\n### Structuring the database and its schemas\n\nIt is recommended to group together semantically coherent objects, by importing them to the same database schema.\nOne database can have different schemas.\n\nWhile the current data model supports the import of any type of CityJSON objects together (`Building` and `SolitaryVegetationObject`), the data becomes harder to manage for the user. \nExample of this would be having different attributes for the same CityObject type (which should be consistent for data coming from the same source).\n\n\n### Input == CityJSONFeature\nThe importer works only on [*CityJSONL* files](https://www.cityjson.org/specs/#text-sequences-and-streaming-with-cityjsonfeature), that is where a CityJSON file is decomposed into its *features* (`CityJSONFeature`).\n\nThe easiest way to create these from a CityJSON file is with [cjio](https://github.com/cityjson/cjio), and to follow [those instructions](https://github.com/cityjson/cjio#stdin-and-stdout).\n\nThe importer supports 3 kinds of input:\n  1. a single CityJSONL file (only those as the output of cjio currently work)\n  1. a directory of CityJSONL files (all files with *jsonl* extensions are located and imported)\n  1. STDIN using the pipe operator: `cat file.jsonl | cjdb ...`\n\n\n\n### Coordinate Reference Systems\nThe `cjdb` importer does not allow inconsistent CRSs (coordinate reference systems) within the same database schema. For storing data in separate CRSs, you have to use different schemas.\n\nThe data needs to be either harmonized beforehand, or the `-I/--srid` flag can be used upon import, to reproject all the geometries to the one specified CRS. \nSpecifying a 2D CRS (instead of a 3D one) will cause the Z-coordinates to remain unchanged.\n\n**Note:** reprojections slow down the import significantly.\n\n**Note:** Source data with missing `"metadata"/"referenceSystem"` cannot be reprojected due to unknown source reference system.\n\n\n### 3D reprojections\n[`pyproj`](https://pyproj4.github.io/pyproj/stable/) is used for CRS reprojections. \nWhile it supports 3D CRS transformations between different systems, sometimes downloading additional [grids](https://pyproj4.github.io/pyproj/stable/transformation_grids.html) is required. \nThe importer will attempt to download the grids needed for the reprojection, with the following message:\n\n```\nAttempting to download additional grids required for CRS transformation.\nThis can also be done manually, and the files should be put in this folder:\n        {pyproj_directory}\n```\n\nIf that fails, the user will have to download the required grids and put them in the printed `{pyproj_directory}` themselves. \n\n\n### CityJSON Extensions\nIf [CityJSON Extensions](https://www.cityjson.org/extensions/) are present in the imported files, they can be found listed in the `extensions` column in the `import_meta` table.\n\nThe [CityJSON specifications](https://www.cityjson.org/specs/#extensions) mention 3 different extendable features, and the `cjdb` importer deals with them as follows:\n\n1. Complex attributes\n\nNo action is taken. These attributes end up in the `attributes` JSONB column.\n\n2. Additional root properties\n\nAdditional root properties are placed in the `extra properties` JSONB column in the `import_meta` table.\n\n3. Additional CityObject type\n\nAdditional CityObject types are appended to the list of allowed CityJSON objects.\n\n### CityJSON GeometryTemplate\n[Geometry templates](https://www.cityjson.org/specs/1.1.2/#geometry-templates)\nare resolved for each object geometry, so that the object in the table ends up with its real-world coordinates (instead of vertex references or relative template coordinates).\n\n### Data validation\nThe importer does not validate the structure of the file. It is assumed that the input file is schema-valid ([CityJSON validator](https://validator.cityjson.org/)).\nIt sends out warnings when:\n- there appear CityObject types defined neither in the main CityJSON specification nor any of the supplied extensions. \n- the specified target CRS does not have the Z-axis defined\n- the source dataset does not have a CRS defined at all\n\n### Repeated object IDs\nBy default, the importer does not check if an object with a given ID exists already in the database. This is because such an operation for every inserted object results in a performance penalty.\n\nThe user can choose to run the import with either the `-e/--skip-existing` option to skip existing objects or `-u, --update-existing` to update existing objects. This will slow down the import, but it will also ensure that repeated object cases are handled.\n\n\n\n\n',
    'author': 'Cynthia Cai',
    'author_email': 'None',
    'maintainer': 'Gina Stavropoulou',
    'maintainer_email': 'g.stavropoulou@tudelft.nl',
    'url': 'https://github.com/tudelft3d/cjdb',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.11,<4.0',
}


setup(**setup_kwargs)
