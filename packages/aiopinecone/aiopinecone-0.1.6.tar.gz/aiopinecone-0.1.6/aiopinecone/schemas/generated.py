# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2023-04-19T20:16:51+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, conint, constr


class ApproximatedConfig(BaseModel):
    hybrid: Optional[bool] = False
    k_bits: Optional[int] = 512


class CollectionMeta(BaseModel):
    name: Optional[str] = Field(None, example="example-collection")
    size: Optional[int] = Field(
        None, description="The size of the collection in bytes.", example=1
    )
    status: Optional[str] = Field(
        None, description="The status of the collection.", example="created"
    )


class CreateCollectionRequest(BaseModel):
    name: str = Field(
        ...,
        description="The name of the collection to be created.",
        example="example-collection",
    )
    source: str = Field(
        ...,
        description="The name of the source index to be used as the source for the collection.",
        example="example-source-index",
    )


class CreateRequest(BaseModel):
    dimension: int = Field(
        ...,
        description="The dimensions of the vectors to be inserted in the index",
        example=1024,
    )
    index_config: Optional[ApproximatedConfig] = None
    index_type: Optional[str] = Field(
        "approximated",
        description="The type of vector index. Pinecone supports 'approximated'.",
    )
    metadata_config: Optional[Dict[str, Any]] = Field(
        None,
        description='Configuration for the behavior of Pinecone\'s internal metadata index. By default, all metadata is indexed; when `metadata_config` is present, only specified metadata fields are indexed. To specify metadata fields to index, provide a JSON object of the following form: \n  ``` \n {"indexed": ["example_metadata_field"]} \n ``` ',
    )
    metric: Optional[str] = Field(
        "cosine",
        description="The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'.",
    )
    name: str = Field(
        ...,
        description="The name of the index to be created. The maximum length is 45 characters.",
        example="example-index",
    )
    pod_type: Optional[str] = Field(
        "p1.x1",
        description="The type of pod to use. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.",
    )
    pods: Optional[int] = Field(
        1, description="The number of pods for the index to use,including replicas."
    )
    replicas: Optional[int] = Field(
        1,
        description="The number of replicas. Replicas duplicate your index. They provide higher availability and throughput.",
    )
    source_collection: Optional[str] = Field(
        None, description="The name of the collection to create an index from"
    )


class Database(BaseModel):
    dimension: Optional[str] = None
    index_config: Optional[ApproximatedConfig] = None
    index_type: Optional[str] = None
    metadata_config: Optional[Dict[str, Any]] = None
    metric: Optional[str] = None
    name: Optional[str] = None
    pod_type: Optional[str] = None
    pods: Optional[int] = None
    replicas: Optional[int] = None
    shards: Optional[int] = None
    status: Optional[Status] = None


class DeleteRequest(BaseModel):
    deleteAll: Optional[bool] = Field(
        "false",
        description="This indicates that all vectors in the index namespace should be deleted.",
        example=False,
    )
    filter: Optional[Dict[str, Any]] = Field(
        None,
        description="If specified, the metadata filter here will be used to select the vectors to delete. This is mutually exclusive\nwith specifying ids to delete in the ids param or using delete_all=True.\nSee https://www.pinecone.io/docs/metadata-filtering/.",
    )
    ids: Optional[List[str]] = Field(
        None, description="Vectors to delete.", example=["id-0", "id-1"]
    )
    namespace: Optional[str] = Field(
        None,
        description="The namespace to delete vectors from, if applicable.",
        example="example-namespace",
    )


class DeleteResponse(BaseModel):
    pass


class DescribeIndexStatsRequest(BaseModel):
    filter: Optional[Dict[str, Any]] = Field(
        None,
        description="If this parameter is present, the operation only returns statistics\nfor vectors that satisfy the filter.\nSee https://www.pinecone.io/docs/metadata-filtering/.",
    )


class DescribeIndexStatsResponse(BaseModel):
    dimension: Optional[int] = Field(
        None, description="The dimension of the indexed vectors.", example=1024
    )
    indexFullness: Optional[float] = Field(
        None,
        description="The fullness of the index, regardless of whether a metadata filter expression was passed. The granularity of this metric is 10%.",
        example=0.4,
    )
    namespaces: Optional[Dict[str, NamespaceSummary]] = Field(
        None,
        description="A mapping for each namespace in the index from the namespace name to a\nsummary of its contents. If a metadata filter expression is present, the\nsummary will reflect only vectors matching that expression.",
    )
    totalVectorCount: Optional[int] = Field(
        None,
        example=80000,
        title="The total number of vectors in the index, regardless of whether a metadata filter expression was passed",
    )


class FetchResponse(BaseModel):
    namespace: Optional[str] = Field(
        None, description="The namespace of the vectors.", example="example-namespace"
    )
    vectors: Optional[Dict[str, Vector]] = Field(
        None,
        title="The fetched vectors, in the form of a map between the fetched ids and the fetched vectors",
    )


class HnswConfig(BaseModel):
    M: Optional[int] = 12
    ef: Optional[int] = 250
    ef_construction: Optional[int] = 500
    max_elements: Optional[int] = 50000000


class IndexMeta(BaseModel):
    database: Optional[Database] = None


class NamespaceSummary(BaseModel):
    vectorCount: Optional[int] = Field(
        None,
        description="The number of vectors stored in this namespace. Note that updates to this field may lag behind updates to the\nunderlying index and corresponding query results, etc.",
        example=50000,
    )


class PatchRequest(BaseModel):
    pod_type: Optional[str] = Field(
        None,
        description="The new pod type for the index. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.",
        example="s1.x2",
    )
    replicas: Optional[int] = Field(
        None, description="The desired number of replicas for the index.", example=3
    )


class ProtobufAny(BaseModel):
    typeUrl: Optional[str] = None
    value: Optional[str] = None


class ProtobufNullValue(Enum):
    NULL_VALUE = "NULL_VALUE"


class QueryRequest(BaseModel):
    filter: Optional[Dict[str, Any]] = Field(
        None,
        description="The filter to apply. You can use vector metadata to limit your search. See https://www.pinecone.io/docs/metadata-filtering/.",
        example={
            "genre": {"$in": ["comedy", "documentary", "drama"]},
            "year": {"$eq": 2019},
        },
    )
    id: Optional[constr(max_length=512)] = Field(
        None,
        description="The unique ID of the vector to be used as a query vector. Each `query()` request can contain only one of the parameters `queries`, `vector`, or  `id`.",
        example="example-vector-1",
    )
    includeMetadata: Optional[bool] = Field(
        "false",
        description="Indicates whether metadata is included in the response as well as the ids.",
        example=True,
    )
    includeValues: Optional[bool] = Field(
        "false",
        description="Indicates whether vector values are included in the response.",
        example=True,
    )
    namespace: Optional[str] = Field(
        None, description="The namespace to query.", example="example-namespace"
    )
    queries: Optional[List[QueryVector]] = Field(
        None,
        description="DEPRECATED. The query vectors. Each `query()` request can contain only one of the parameters `queries`, `vector`, or  `id`.",
    )
    sparseVector: Optional[SparseValues] = None
    topK: conint(ge=1, le=10000) = Field(
        ..., description="The number of results to return for each query.", example=10
    )
    vector: Optional[List[float]] = Field(
        None,
        description="The query vector. This should be the same length as the dimension of the index being queried. Each `query()` request can contain only one of the parameters `id` or `vector`.",
        example=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
    )


class QueryResponse(BaseModel):
    matches: Optional[List[ScoredVector]] = Field(
        None, description="The matches for the vectors."
    )
    namespace: Optional[str] = Field(None, description="The namespace for the vectors.")


class QueryVector(BaseModel):
    filter: Optional[Dict[str, Any]] = Field(
        None,
        description="An override for the metadata filter to apply. This replaces the request-level filter.",
        example={
            "genre": {"$in": ["comedy", "documentary", "drama"]},
            "year": {"$eq": 2019},
        },
    )
    namespace: Optional[str] = Field(
        None,
        description="An override the namespace to search.",
        example="example-namespace",
    )
    sparseValues: Optional[SparseValues] = None
    topK: Optional[conint(ge=1, le=10000)] = Field(
        None,
        description="An override for the number of results to return for this query vector.",
        example=10,
    )
    values: List[float] = Field(
        ...,
        description="The query vector values. This should be the same length as the dimension of the index being queried.",
        example=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
    )


class RpcStatus(BaseModel):
    code: Optional[int] = None
    details: Optional[List[ProtobufAny]] = None
    message: Optional[str] = None


class ScoredVector(BaseModel):
    id: constr(min_length=1, max_length=512) = Field(
        ..., description="This is the vector's unique id.", example="example-vector-1"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="This is the metadata, if it is requested.",
        example={"genre": "documentary", "year": 2019},
    )
    score: Optional[float] = Field(
        None,
        description="This is a measure of similarity between this vector and the query vector.  The higher the score, the more they are similar.",
        example=0.08,
    )
    sparseValues: Optional[SparseValues] = None
    values: Optional[List[float]] = Field(
        None,
        description="This is the vector data, if it is requested.",
        example=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
    )


class SingleQueryResults(BaseModel):
    matches: Optional[List[ScoredVector]] = Field(
        None, description="The matches for the vectors."
    )
    namespace: Optional[str] = Field(
        None, description="The namespace for the vectors.", example="example-namespace"
    )


class SparseValues(BaseModel):
    indices: List[int] = Field(
        ...,
        description="The indices of the sparse data.",
        example=[1, 312, 822, 14, 980],
    )
    values: List[float] = Field(
        ...,
        description="The corresponding values of the sparse data, which must be the same length as the indices.",
        example=[0.1, 0.2, 0.3, 0.4, 0.5],
    )


class State(Enum):
    Initializing = "Initializing"
    ScalingUp = "ScalingUp"
    ScalingDown = "ScalingDown"
    Terminating = "Terminating"
    Ready = "Ready"


class Status(BaseModel):
    ready: Optional[bool] = None
    state: Optional[State] = None


class UpdateRequest(BaseModel):
    id: constr(min_length=1, max_length=512) = Field(
        ..., description="Vector's unique id.", example="example-vector-1"
    )
    namespace: Optional[str] = Field(
        None,
        description="The namespace containing the vector to update.",
        example="example-namespace",
    )
    setMetadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Metadata to *set* for the vector.",
        example={"genre": "documentary", "year": 2019},
    )
    sparseValues: Optional[SparseValues] = None
    values: Optional[List[float]] = Field(
        None,
        description="Vector data.",
        example=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
    )


class UpdateResponse(DeleteResponse):
    pass


class UpsertRequest(BaseModel):
    namespace: Optional[str] = Field(
        None,
        description="This is the namespace name where you upsert vectors.",
        example="example-namespace",
    )
    vectors: List[Vector] = Field(
        ...,
        description="An array containing the vectors to upsert. Recommended batch limit is 100 vectors.",
    )


class UpsertResponse(BaseModel):
    upsertedCount: Optional[int] = Field(
        None, description="The number of vectors upserted.", example=10
    )


class Vector(BaseModel):
    id: constr(min_length=1, max_length=512) = Field(
        ..., description="This is the vector's unique id.", example="example-vector-1"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="This is the metadata included in the request.",
        example={"genre": "documentary", "year": 2019},
    )
    sparseValues: Optional[SparseValues] = None
    values: List[float] = Field(
        ...,
        description="This is the vector data included in the request.",
        example=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
    )
