{"version":3,"sources":["AntMenu.tsx","index.tsx"],"names":["Icons","parseMenuItems","data","map","item","menuItem","key","label","icon","undefined","children","danger","disabled","Icon","React","createElement","error","console","warn","match","dangerouslySetInnerHTML","__html","get_height_menu","menu_array","Array","from","document","getElementsByClassName","menu_height","forEach","element","height","offsetHeight","Object","keys","AllIcons","withStreamlitConnection","props","args","menu_data","defaultSelectedKeys","defaultOpenKeys","additionalHeight","multiple","css_styling","theme","useState","openKeys","setOpenKeys","rootSubmenuKeys","useEffect","Streamlit","setFrameHeight","id","mode","onOpenChange","latestOpenKey","find","indexOf","setTimeout","setComponentValue","style","width","borderRight","overflow","borderRadius","items","onClick","ReactDOM","render","StrictMode","getElementById"],"mappings":"gPAeMA,EAA4C,GAiClD,SAASC,EAAeC,GACtB,OAAOA,EAAKC,KAAI,SAACC,GACf,IAAMC,EAAqB,CACzBC,IAAKF,EAAKE,IACVC,MAAO,GACPC,UAAMC,EACNC,SAAUN,EAAKM,SAAWT,EAAeG,EAAKM,eAAYD,EAC1DE,SAAQP,EAAKO,OACbC,WAAUR,EAAKQ,UAEjB,GAAIR,EAAKI,KACP,IACE,IAAMK,EAAOb,EAAMI,EAAKI,MACpBK,IACFR,EAASG,KAAOM,IAAMC,cAAcF,IAEtC,MAAOG,GACPC,QAAQC,KAAK,8BAAD,OAA+Bd,EAAKI,KAAI,MAAMQ,GAc9D,OAXIZ,EAAKG,QACHH,EAAKG,MAAMY,MAAM,WACnBd,EAASE,MACP,0BACEa,wBAAyB,CAAEC,OAAQjB,EAAKG,SAI5CF,EAASE,MAAQH,EAAKG,OAGnBF,KAuDX,SAASiB,IACP,IAAIC,EAAaC,MAAMC,KAAKC,SAASC,uBAAuB,aACxDC,EAAc,EAelB,OAdAL,EAAWM,SAAQ,SAACC,GAClB,IAAIC,EAAUD,EAAwBE,aAGlCD,GAEEA,EAAS,IAAM,IACjBH,EAAcG,MAKpBH,GAA4B,IArI9BK,OAAOC,KAAKC,GAAUN,SAAQ,SAACvB,GAC7BN,EAAMM,GAAgC6B,EAAS7B,MA4IjD,IA0De8B,eA1DO,SAACC,GACrB,MAAgHA,EAAMC,KAA9GC,EAAS,EAATA,UAAWjC,EAAG,EAAHA,IAAKkC,EAAmB,EAAnBA,oBAAqBC,EAAe,EAAfA,gBAAiBC,EAAgB,EAAhBA,iBAAkBC,EAAQ,EAARA,SAAUC,EAAW,EAAXA,YAAaC,EAAK,EAALA,MACvG,EAAgCC,mBAAmB,IAAG,mBAA/CC,EAAQ,KAAEC,EAAW,KAEtBC,EAAkBV,EAAUpC,KAAI,SAACC,GAAS,OAAKA,EAAKE,OAG1D4C,qBAAU,WACRC,IAAUC,mBACT,IAqBH,OACE,kBAAC,IAAI,CACJC,GAAO/C,EACNgD,KAAK,SACLP,SAAUA,EACVQ,aAxB4C,SAACrB,GAC/C,IAAMsB,EAAgBtB,EAAKuB,MAAK,SAACnD,GAAG,OAAgC,IAA3ByC,EAASW,QAAQpD,OACT,IAA7C2C,EAAgBS,QAAQF,IAC1BR,EAAYd,GACZyB,YAAW,WACT,IAAI5B,EAAST,IACb6B,IAAUC,eAAerB,EAASW,KACjC,OAEHS,IAAUS,kBAAkB1B,GAC5Bc,EAAYQ,EAAgB,CAACA,GAAiB,IAE9CG,YAAW,WACT,IAAI5B,EAAST,IACb6B,IAAUC,eAAerB,EAASW,KACjC,OAUHmB,MAAK,aACHC,MAAO,OACP/B,OAAQ,OACRgC,YAAa,EACbC,SAAU,OACVC,aAAc,QAEXrB,GAELC,MAAOA,EACPqB,MAAOjE,EAAesC,GACtB4B,QAAS,YAAc,IAAX7D,EAAG,EAAHA,IACV6C,IAAUS,kBAAkBtD,IAE9BqC,SAAUA,EACVH,oBAAqB,CAACA,GACtBC,gBAAiB,CAACA,QCxMxB2B,IAASC,OACP,kBAAC,IAAMC,WAAU,KACf,kBAAC,EAAa,OAEhB5C,SAAS6C,eAAe,W","file":"static/js/main.8164a591.chunk.js","sourcesContent":["import { Menu } from \"antd\";\r\nimport { MenuProps } from \"antd/lib/menu\";\r\nimport React, { useEffect, useState } from \"react\";\r\nimport {\r\n  ComponentProps,\r\n  Streamlit,\r\n  withStreamlitConnection,\r\n} from \"streamlit-component-lib\";\r\nimport * as AllIcons from \"@ant-design/icons\";\r\nimport { ComponentType } from \"react\";\r\n\r\n\r\n\r\n\r\n// Create a mapping of all available Ant Design icons\r\nconst Icons: Record<string, ComponentType<any>> = {};\r\nObject.keys(AllIcons).forEach((key) => {\r\n  Icons[key as keyof typeof AllIcons] = AllIcons[key as keyof typeof AllIcons] as ComponentType<any>;\r\n});\r\n\r\n\r\n\r\n//Define the shape of each menu item\r\ninterface MenuItem {\r\n  key: string;\r\n  label: string;\r\n  icon?: React.ReactNode;\r\n  children?: MenuItem[];\r\n  type?: \"group\";\r\n  danger?: boolean;\r\n  disabled?: boolean;\r\n}\r\n// interface MenuItem {\r\n//   key: string;\r\n//   label: React.ReactNode;\r\n//   icon?: React.ReactNode;\r\n//   children?: MenuItem[];\r\n//   type?: \"group\";\r\n//   danger?: boolean;\r\n//   disabled?: boolean;\r\n//   divider?: boolean;\r\n// }\r\n// // /**\r\n//  * Recursively parse a hierarchical list of menu items into the expected format.\r\n//  * @param data The raw menu data to be parsed\r\n//  * @returns An array of MenuItem objects\r\n//  */\r\n\r\nfunction parseMenuItems(data: any[]): MenuItem[] {\r\n  return data.map((item: any) => {\r\n    const menuItem: MenuItem = {\r\n      key: item.key,\r\n      label: \"\",\r\n      icon: undefined,\r\n      children: item.children ? parseMenuItems(item.children) : undefined,\r\n      danger: item.danger ? true : false,\r\n      disabled: item.disabled ? true : false,\r\n    };\r\n    if (item.icon) {\r\n      try {\r\n        const Icon = Icons[item.icon];\r\n        if (Icon) {\r\n          menuItem.icon = React.createElement(Icon);\r\n        }\r\n      } catch (error) {\r\n        console.warn(`Failed to create icon for \"${item.icon}\":`, error);\r\n      }\r\n    }\r\n    if (item.label) {\r\n      if (item.label.match(/<(.*?)>/)) {\r\n        menuItem.label = (\r\n          <span\r\n            dangerouslySetInnerHTML={{ __html: item.label }}\r\n          ></span>\r\n        ) as unknown as string;\r\n      } else {\r\n        menuItem.label = item.label as string;\r\n      }\r\n    }\r\n    return menuItem;\r\n  });\r\n}\r\n\r\n// function parseMenuItems(data: any[]): MenuItem[] {\r\n//   const result: MenuItem[] = [];\r\n\r\n//   for (const item of data) {\r\n//     if (item.divider) {\r\n//       result.push({ divider: true } as MenuItem);\r\n//     } else {\r\n//       const menuItem: MenuItem = {\r\n//         key: item.key,\r\n//         label: \"\",\r\n//         icon: undefined,\r\n//         children: item.children ? parseMenuItems(item.children) : undefined,\r\n//         danger: item.danger ? true : false,\r\n//         disabled: item.disabled ? true : false,\r\n//       };\r\n\r\n//       if (item.icon) {\r\n//         try {\r\n//           const Icon = Icons[item.icon];\r\n//           if (Icon) {\r\n//             menuItem.icon = React.createElement(Icon);\r\n//           }\r\n//         } catch (error) {\r\n//           console.warn(`Failed to create icon for \"${item.icon}\":`, error);\r\n//         }\r\n//       }\r\n\r\n//       if (item.label) {\r\n//         if (item.label.match(/<(.*?)>/)) {\r\n//           menuItem.label = (\r\n//             <span\r\n//               dangerouslySetInnerHTML={{ __html: item.label }}\r\n//             ></span>\r\n//           ) as unknown as string;\r\n//         } else {\r\n//           menuItem.label = item.label as string;\r\n//         }\r\n//       }\r\n\r\n//       result.push(menuItem);\r\n//     }\r\n//   }\r\n\r\n//   return result;\r\n// }\r\n\r\n\r\n/**\r\n * Get the height of the menu component, taking into account any additional height specified by the user.\r\n * @returns The total height of the menu, in pixels\r\n */\r\nfunction get_height_menu() {\r\n  var menu_array = Array.from(document.getElementsByClassName(\"ant-menu\"));\r\n  var menu_height = 0;\r\n  menu_array.forEach((element) => {\r\n    var height = (element as HTMLElement).offsetHeight;\r\n\r\n    //if height is an integer return it\r\n    if (height) {\r\n      //test integer\r\n      if (height % 1 === 0) {\r\n        menu_height = height;\r\n      }\r\n    }\r\n  });\r\n\r\n  menu_height = menu_height + 100;\r\n\r\n  return menu_height;\r\n}\r\n\r\n/**\r\n * A React component that renders an Ant Design menu based on the provided menu data.\r\n */\r\nconst MenuComponent = (props: ComponentProps) => {\r\n  const { menu_data, key, defaultSelectedKeys, defaultOpenKeys, additionalHeight, multiple, css_styling, theme} = props.args;\r\n  const [openKeys, setOpenKeys] = useState<string[]>([]);\r\n\r\n  const rootSubmenuKeys = menu_data.map((item: any) => item.key);\r\n\r\n  // Set the height of the Streamlit iframe to match the height of the menu\r\n  useEffect(() => {\r\n    Streamlit.setFrameHeight();\r\n  }, []);\r\n\r\n  const onOpenChange: MenuProps['onOpenChange'] = (keys) => {\r\n    const latestOpenKey = keys.find((key) => openKeys.indexOf(key) === -1);\r\n    if (rootSubmenuKeys.indexOf(latestOpenKey!) === -1) {\r\n      setOpenKeys(keys);\r\n      setTimeout(() => {\r\n        var height = get_height_menu()\r\n        Streamlit.setFrameHeight(height + additionalHeight);\r\n      }, 250);\r\n    } else {\r\n      Streamlit.setComponentValue(keys);\r\n      setOpenKeys(latestOpenKey ? [latestOpenKey] : []);\r\n  \r\n      setTimeout(() => {\r\n        var height = get_height_menu()\r\n        Streamlit.setFrameHeight(height + additionalHeight);\r\n      }, 250);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Menu\r\n     id  = {key}\r\n      mode=\"inline\"\r\n      openKeys={openKeys}\r\n      onOpenChange={onOpenChange}\r\n      style={{\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        borderRight: 0,\r\n        overflow: \"auto\",\r\n        borderRadius: \"20px\",\r\n       // backgroundColor: \"#fff\",\r\n        ...css_styling\r\n      }}\r\n      theme={theme}\r\n      items={parseMenuItems(menu_data)}\r\n      onClick={({ key }) => {\r\n        Streamlit.setComponentValue(key);\r\n      }}\r\n      multiple={multiple}\r\n      defaultSelectedKeys={[defaultSelectedKeys]}\r\n      defaultOpenKeys={[defaultOpenKeys]}\r\n\r\n    />\r\n  );\r\n};\r\n\r\nexport default withStreamlitConnection(MenuComponent);","\r\nimport React from \"react\"\r\nimport ReactDOM from \"react-dom\"\r\nimport MenuComponent from \"./AntMenu\"\r\n\r\n// Lots of import to define a Styletron engine and load the light theme of baseui\r\n\r\n\r\n// Wrap your CustomSlider with the baseui them\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <MenuComponent />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n)"],"sourceRoot":""}