# coding: utf-8

"""
    Marqeta Core API

    Simplified management of your payment programs  # noqa: E501

    The version of the OpenAPI document: 3.0.0
    Contact: dev@swadesh.co
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Dict, Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, validator
from marqeta_client.models.activation_actions import ActivationActions
from marqeta_client.models.card_fulfillment_response import CardFulfillmentResponse

class CardResponse(BaseModel):
    """
    CardResponse
    """
    created_time: datetime = Field(..., description="yyyy-MM-ddTHH:mm:ssZ")
    last_modified_time: datetime = Field(..., description="yyyy-MM-ddTHH:mm:ssZ")
    token: StrictStr = Field(..., description="36 char max")
    user_token: StrictStr = Field(..., description="36 char max")
    card_product_token: StrictStr = Field(..., description="36 char max")
    last_four: StrictStr = ...
    pan: StrictStr = ...
    expiration: StrictStr = ...
    expiration_time: datetime = Field(..., description="yyyy-MM-ddTHH:mm:ssZ")
    cvv_number: Optional[StrictStr] = None
    chip_cvv_number: Optional[StrictStr] = None
    barcode: StrictStr = ...
    pin_is_set: StrictBool = ...
    state: StrictStr = ...
    state_reason: StrictStr = ...
    fulfillment_status: StrictStr = ...
    reissue_pan_from_card_token: Optional[StrictStr] = None
    new_pan_from_card_token: Optional[StrictStr] = None
    fulfillment: Optional[CardFulfillmentResponse] = None
    bulk_issuance_token: Optional[StrictStr] = None
    translate_pin_from_card_token: Optional[StrictStr] = None
    activation_actions: Optional[ActivationActions] = None
    instrument_type: Optional[StrictStr] = None
    expedite: Optional[StrictBool] = False
    metadata: Optional[Dict[str, StrictStr]] = None
    contactless_exemption_counter: Optional[StrictInt] = None
    contactless_exemption_total_amount: Optional[Union[StrictFloat, StrictInt]] = None
    __properties = ["created_time", "last_modified_time", "token", "user_token", "card_product_token", "last_four", "pan", "expiration", "expiration_time", "cvv_number", "chip_cvv_number", "barcode", "pin_is_set", "state", "state_reason", "fulfillment_status", "reissue_pan_from_card_token", "new_pan_from_card_token", "fulfillment", "bulk_issuance_token", "translate_pin_from_card_token", "activation_actions", "instrument_type", "expedite", "metadata", "contactless_exemption_counter", "contactless_exemption_total_amount"]

    @validator('state')
    def state_validate_enum(cls, v):
        if v not in ('ACTIVE', 'SUSPENDED', 'TERMINATED', 'UNSUPPORTED', 'UNACTIVATED', 'LIMITED'):
            raise ValueError("must be one of enum values ('ACTIVE', 'SUSPENDED', 'TERMINATED', 'UNSUPPORTED', 'UNACTIVATED', 'LIMITED')")
        return v

    @validator('fulfillment_status')
    def fulfillment_status_validate_enum(cls, v):
        if v not in ('ISSUED', 'ORDERED', 'REORDERED', 'REJECTED', 'SHIPPED', 'DELIVERED', 'DIGITALLY_PRESENTED'):
            raise ValueError("must be one of enum values ('ISSUED', 'ORDERED', 'REORDERED', 'REJECTED', 'SHIPPED', 'DELIVERED', 'DIGITALLY_PRESENTED')")
        return v

    @validator('instrument_type')
    def instrument_type_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('PHYSICAL_MSR', 'PHYSICAL_ICC', 'PHYSICAL_CONTACTLESS', 'PHYSICAL_COMBO', 'VIRTUAL_PAN'):
            raise ValueError("must be one of enum values ('PHYSICAL_MSR', 'PHYSICAL_ICC', 'PHYSICAL_CONTACTLESS', 'PHYSICAL_COMBO', 'VIRTUAL_PAN')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CardResponse:
        """Create an instance of CardResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of fulfillment
        if self.fulfillment:
            _dict['fulfillment'] = self.fulfillment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of activation_actions
        if self.activation_actions:
            _dict['activation_actions'] = self.activation_actions.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CardResponse:
        """Create an instance of CardResponse from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return CardResponse.parse_obj(obj)

        _obj = CardResponse.parse_obj({
            "created_time": obj.get("created_time"),
            "last_modified_time": obj.get("last_modified_time"),
            "token": obj.get("token"),
            "user_token": obj.get("user_token"),
            "card_product_token": obj.get("card_product_token"),
            "last_four": obj.get("last_four"),
            "pan": obj.get("pan"),
            "expiration": obj.get("expiration"),
            "expiration_time": obj.get("expiration_time"),
            "cvv_number": obj.get("cvv_number"),
            "chip_cvv_number": obj.get("chip_cvv_number"),
            "barcode": obj.get("barcode"),
            "pin_is_set": obj.get("pin_is_set") if obj.get("pin_is_set") is not None else False,
            "state": obj.get("state"),
            "state_reason": obj.get("state_reason"),
            "fulfillment_status": obj.get("fulfillment_status"),
            "reissue_pan_from_card_token": obj.get("reissue_pan_from_card_token"),
            "new_pan_from_card_token": obj.get("new_pan_from_card_token"),
            "fulfillment": CardFulfillmentResponse.from_dict(obj.get("fulfillment")) if obj.get("fulfillment") is not None else None,
            "bulk_issuance_token": obj.get("bulk_issuance_token"),
            "translate_pin_from_card_token": obj.get("translate_pin_from_card_token"),
            "activation_actions": ActivationActions.from_dict(obj.get("activation_actions")) if obj.get("activation_actions") is not None else None,
            "instrument_type": obj.get("instrument_type"),
            "expedite": obj.get("expedite") if obj.get("expedite") is not None else False,
            "metadata": obj.get("metadata"),
            "contactless_exemption_counter": obj.get("contactless_exemption_counter"),
            "contactless_exemption_total_amount": obj.get("contactless_exemption_total_amount")
        })
        return _obj

