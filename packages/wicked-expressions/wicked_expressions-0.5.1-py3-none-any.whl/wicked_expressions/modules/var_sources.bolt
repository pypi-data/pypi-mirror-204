from bolt_expressions.node import ExpressionNode
import base64
import inspect
import nbtlib

from ./sources import ScoreSource, DataSource
from ./utils import logger, defer
from ./config import Config


class BaseVar:
    _var_type = ''
    _location_index = -1
    _static_cache = {}

    @classmethod
    def _evaluate_location_index(cls, is_static: bool) -> int:
        if not is_static:
            cls._location_index += 1
            return cls._location_index

        frame_context = cls._get_frame_context()
        cache_key = base64_encode(f"{frame_context[0]}#{frame_context[1]}")

        retrieved_index = cls._static_cache.get(cache_key)

        if retrieved_index == None:
            cls._location_index += 1
            cls._static_cache[cache_key] = cls._location_index
            return cls._location_index

        return retrieved_index

    @classmethod
    def _monkeypatch(cls, Scoreboard, Data):
        cls._main_scoreboard = Scoreboard(Config.SCOREBOARD_ROOT)
        cls._main_storage = Data.storage(Config.STORAGE_ROOT)

    @staticmethod
    def _get_frame_context() -> tuple:
        frame = inspect.getouterframes(inspect.currentframe(), 2)[4]
        path = frame.filename[len(str(ctx.directory)):]
        return (frame.lineno, path)

    @defer
    @staticmethod
    def flush_variables_setup():
        BoolSource._flush_on_load()
        ByteSource._flush_on_load()
        ShortSource._flush_on_load()
        IntSource._flush_on_load()
        LongSource._flush_on_load()
        FloatSource._flush_on_load()
        DoubleSource._flush_on_load()
        StringSource._flush_on_load()
        ListSource._flush_on_load()


class VarScoreSource(ScoreSource, BaseVar):
    @classmethod
    def create(cls, is_static: bool):
        location_index = cls._evaluate_location_index(is_static)
        return cls(f"${ctx.project_id}#{cls._var_type}${location_index}", Config.SCOREBOARD_ROOT)

    @classmethod
    def _flush_on_load(cls):
        mcfunc_path = f"{Config.ROOT_LOCAL}/runtime_var_flush_score"

        for index in range(cls._location_index+1):
            merge function_tag minecraft:load {"values": [mcfunc_path]}
            append function mcfunc_path:
                scoreboard players reset f"${ctx.project_id}#{cls._var_type}${index}" Config.SCOREBOARD_ROOT

class VarStorageSource(DataSource, BaseVar):
    @classmethod
    def create(cls, is_static: bool):
        location_index = cls._evaluate_location_index(is_static)
        return cls('storage', Config.STORAGE_ROOT)[ctx.project_id]['data'][cls._var_type][location_index]

    @classmethod
    def _flush_on_load(cls):
        mcfunc_path = f"{Config.ROOT_LOCAL}/runtime_var_flush_storage"

        if cls._location_index < 0:
            return 0

        fresh_slots = []
        for n in range(cls._location_index+1):
            fresh_slots.append(cls._default_slot_value)

        merge function_tag minecraft:load {"values": [mcfunc_path]}
        append function mcfunc_path:
            nbt_path = f"{ctx.project_id}.data.{cls._var_type}"
            data modify storage Config.STORAGE_ROOT nbt_path set value fresh_slots

class BoolSource(VarScoreSource):
    _var_type = 'bool'

    def _rebind(self, score, value):
        if not isinstance(value, ExpressionNode):
            value = int(value)
            
            if value not in (0, 1):
                return logger.error(f"Invalid assignment attempt of value {value} to a Bool variable.")

        return super()._rebind(score, value)

class ByteSource(VarStorageSource):
    _default_nbt_type = 'byte'
    _default_slot_value = nbtlib.Byte(0)
    _var_type = 'byte'

    def _rebind(self, source, value):
        if not isinstance(value, ExpressionNode):
            value = nbtlib.Byte(value)
        return super()._rebind(source, value)

class ShortSource(VarStorageSource):
    _default_nbt_type = 'short'
    _default_slot_value = nbtlib.Short(0)
    _var_type = 'short'

    def _rebind(self, source, value):
        if not isinstance(value, ExpressionNode):
            value = nbtlib.Short(value)
        return super()._rebind(source, value)

class IntSource(VarScoreSource):
    _var_type = 'int'

class LongSource(VarStorageSource):
    _default_nbt_type = 'long'
    _default_slot_value = nbtlib.Long(0)
    _var_type = 'long'

    def _rebind(self, source, value):
        if not isinstance(value, ExpressionNode):
            value = nbtlib.Long(value)
        return super()._rebind(source, value)

# float <-> double
# 0.000000953674316
# 1048576

class FloatSource(VarStorageSource):
    _default_nbt_type = 'float'
    _default_slot_value = nbtlib.Float(0)
    _var_type = 'float'

    def _rebind(self, source, value):
        if not isinstance(value, ExpressionNode):
            value = nbtlib.Float(value)
        return super()._rebind(source, value)

class DoubleSource(VarStorageSource):
    _default_nbt_type = 'double'
    _default_slot_value = nbtlib.Double(0)
    _var_type = 'double'

    def _rebind(self, source, value):
        if not isinstance(value, ExpressionNode):
            value = nbtlib.Double(value)
        return super()._rebind(source, value)

class StringSource(VarStorageSource):
    _default_nbt_type = 'string'
    _default_slot_value = nbtlib.String('')
    _var_type = 'string'

    def _rebind(self, source, value):
        if not isinstance(value, ExpressionNode):
            value = nbtlib.String(value)
        return super()._rebind(source, value)

class ListSource(VarStorageSource):
    _default_nbt_type = 'list'
    _var_type = 'list'
    _default_slot_value = []

def base64_encode(s: str) -> str:
    return base64.b64encode(s.encode()).decode()
