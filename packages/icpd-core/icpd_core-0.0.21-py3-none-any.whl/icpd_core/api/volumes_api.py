# coding: utf-8

"""
    IBM CLOUD PAK FOR DATA

    This is the Public API for IBM Cloud Pak for Data  # noqa: E501

    OpenAPI spec version: Beta
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from icpd_core.api_client import ApiClient


class VolumesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def copy_object(self, body, **kwargs):  # noqa: E501
        """Copy file/dir from source to destination  # noqa: E501

        Copy file/dir from source to destination  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_object(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyEntityObject body: Object containing source and destination paths. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param bool keep_source: Set to false if you do not want to retain the entity at the source.
        :param bool destination_in_path: Set to true if you want destination_path contains name of the object thats being copied.
        :param bool overwrite_destination: Set to true if you want to overwrite the entity at the destination in case of conflicts.
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_object_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_object_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def copy_object_with_http_info(self, body, **kwargs):  # noqa: E501
        """Copy file/dir from source to destination  # noqa: E501

        Copy file/dir from source to destination  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_object_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyEntityObject body: Object containing source and destination paths. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param bool keep_source: Set to false if you do not want to retain the entity at the source.
        :param bool destination_in_path: Set to true if you want destination_path contains name of the object thats being copied.
        :param bool overwrite_destination: Set to true if you want to overwrite the entity at the destination in case of conflicts.
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'jwt_auth_user_payload', 'authorization', 'keep_source', 'destination_in_path', 'overwrite_destination']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_object" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_object`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'keep_source' in params:
            query_params.append(('keep_source', params['keep_source']))  # noqa: E501
        if 'destination_in_path' in params:
            query_params.append(('destination_in_path', params['destination_in_path']))  # noqa: E501
        if 'overwrite_destination' in params:
            query_params.append(('overwrite_destination', params['overwrite_destination']))  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/objects/copy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file(self, file_path, **kwargs):  # noqa: E501
        """Delete file from volume  # noqa: E501

        Delete a file or directory from the volume  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file(file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: Path leading upto where the file is uploaded in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param str volume_type: Set to pvc if want to upload file to pvc, set objectstore if want to upload file to objectstore bucket
        :param str bucket_name: Bucket must be set if volume_type is objectstore
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_with_http_info(file_path, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(file_path, **kwargs)  # noqa: E501
            return data

    def delete_file_with_http_info(self, file_path, **kwargs):  # noqa: E501
        """Delete file from volume  # noqa: E501

        Delete a file or directory from the volume  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_with_http_info(file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: Path leading upto where the file is uploaded in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param str volume_type: Set to pvc if want to upload file to pvc, set objectstore if want to upload file to objectstore bucket
        :param str bucket_name: Bucket must be set if volume_type is objectstore
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_path', 'jwt_auth_user_payload', 'authorization', 'volume_type', 'bucket_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_path' is set
        if ('file_path' not in params or
                params['file_path'] is None):
            raise ValueError("Missing the required parameter `file_path` when calling `delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_path' in params:
            path_params['file_path'] = params['file_path']  # noqa: E501

        query_params = []
        if 'volume_type' in params:
            query_params.append(('volume_type', params['volume_type']))  # noqa: E501
        if 'bucket_name' in params:
            query_params.append(('bucket_name', params['bucket_name']))  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/files/{file_path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_directory_contents(self, directory_path, **kwargs):  # noqa: E501
        """Get list of contents in directory  # noqa: E501

        Get list of contents in the directory  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_directory_contents(directory_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str directory_path: Path leading upto where the directory is present in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param bool recursive: Set to true if you want to list contents recursively within the directory.
        :param bool tree: Set to true if you want the response for `recursive=true` to be returned as a tree structure, instead of a list.
        :param bool include_type: (To Be Deprecated Soon) Set to true if you want the response to indicate the type of entity (i.e. file or directory)
        :param bool include_details: Set to true if you want the response to include details about files/directories
        :return: SuccessGetDirectoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_directory_contents_with_http_info(directory_path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_directory_contents_with_http_info(directory_path, **kwargs)  # noqa: E501
            return data

    def get_directory_contents_with_http_info(self, directory_path, **kwargs):  # noqa: E501
        """Get list of contents in directory  # noqa: E501

        Get list of contents in the directory  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_directory_contents_with_http_info(directory_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str directory_path: Path leading upto where the directory is present in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param bool recursive: Set to true if you want to list contents recursively within the directory.
        :param bool tree: Set to true if you want the response for `recursive=true` to be returned as a tree structure, instead of a list.
        :param bool include_type: (To Be Deprecated Soon) Set to true if you want the response to indicate the type of entity (i.e. file or directory)
        :param bool include_details: Set to true if you want the response to include details about files/directories
        :return: SuccessGetDirectoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['directory_path', 'jwt_auth_user_payload', 'authorization', 'recursive', 'tree', 'include_type', 'include_details']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_directory_contents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'directory_path' is set
        if ('directory_path' not in params or
                params['directory_path'] is None):
            raise ValueError("Missing the required parameter `directory_path` when calling `get_directory_contents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'directory_path' in params:
            path_params['directory_path'] = params['directory_path']  # noqa: E501

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501
        if 'tree' in params:
            query_params.append(('tree', params['tree']))  # noqa: E501
        if 'include_type' in params:
            query_params.append(('include_type', params['include_type']))  # noqa: E501
        if 'include_details' in params:
            query_params.append(('include_details', params['include_details']))  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/directories/{directory_path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessGetDirectoryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file(self, file_path, **kwargs):  # noqa: E501
        """Read content of a file or a directory in the volume  # noqa: E501

        Stream content of a file in the volume or download archive iff directory  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file(file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: Path leading upto where the file is uploaded in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param bool dry_run: Set to true to probe the file/directory without actually downloading it
        :param str override_file_name: Pass a string here to override the name of the file downloaded.
        :param str compress: Specify archive value to compress and download directory.
        :param str volume_type: Set to pvc if want to upload file to pvc, set objectstore if want to upload file to objectstore bucket
        :param str bucket_name: Bucket must be set if volume_type is objectstore
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_with_http_info(file_path, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_with_http_info(file_path, **kwargs)  # noqa: E501
            return data

    def get_file_with_http_info(self, file_path, **kwargs):  # noqa: E501
        """Read content of a file or a directory in the volume  # noqa: E501

        Stream content of a file in the volume or download archive iff directory  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_with_http_info(file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: Path leading upto where the file is uploaded in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param bool dry_run: Set to true to probe the file/directory without actually downloading it
        :param str override_file_name: Pass a string here to override the name of the file downloaded.
        :param str compress: Specify archive value to compress and download directory.
        :param str volume_type: Set to pvc if want to upload file to pvc, set objectstore if want to upload file to objectstore bucket
        :param str bucket_name: Bucket must be set if volume_type is objectstore
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_path', 'jwt_auth_user_payload', 'authorization', 'dry_run', 'override_file_name', 'compress', 'volume_type', 'bucket_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_path' is set
        if ('file_path' not in params or
                params['file_path'] is None):
            raise ValueError("Missing the required parameter `file_path` when calling `get_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_path' in params:
            path_params['file_path'] = params['file_path']  # noqa: E501

        query_params = []
        if 'dry_run' in params:
            query_params.append(('dry_run', params['dry_run']))  # noqa: E501
        if 'override_file_name' in params:
            query_params.append(('override_file_name', params['override_file_name']))  # noqa: E501
        if 'compress' in params:
            query_params.append(('compress', params['compress']))  # noqa: E501
        if 'volume_type' in params:
            query_params.append(('volume_type', params['volume_type']))  # noqa: E501
        if 'bucket_name' in params:
            query_params.append(('bucket_name', params['bucket_name']))  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/files/{file_path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_volume_roles(self, volume_name, **kwargs):  # noqa: E501
        """Gets roles of the current user given a list of volumes.  # noqa: E501

        This api gets roles of the current user given a list of volumes. Returns 401 if the user does not have access to even one of the  volume.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_volume_roles(volume_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] volume_name: (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication. Accepts a valid platform or instance token
        :return: SuccessGetRolesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_volume_roles_with_http_info(volume_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_volume_roles_with_http_info(volume_name, **kwargs)  # noqa: E501
            return data

    def get_volume_roles_with_http_info(self, volume_name, **kwargs):  # noqa: E501
        """Gets roles of the current user given a list of volumes.  # noqa: E501

        This api gets roles of the current user given a list of volumes. Returns 401 if the user does not have access to even one of the  volume.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_volume_roles_with_http_info(volume_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] volume_name: (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication. Accepts a valid platform or instance token
        :return: SuccessGetRolesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['volume_name', 'jwt_auth_user_payload', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_volume_roles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'volume_name' is set
        if ('volume_name' not in params or
                params['volume_name'] is None):
            raise ValueError("Missing the required parameter `volume_name` when calling `get_volume_roles`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'volume_name' in params:
            query_params.append(('volume_name', params['volume_name']))  # noqa: E501
            collection_formats['volume_name'] = 'multi'  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessGetRolesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_volumes(self, **kwargs):  # noqa: E501
        """Get volumes that the current user has access to.  # noqa: E501

        This api gets a list of volumes that the current user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_volumes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication. Accepts a valid platform or instance token
        :param bool fetch_all_instances: Only used by Administrator, if true returns all volume instances.
        :param str id: id of the volume
        :param str display_name: query by volume name
        :param str namespace: query by namespace
        :param int offset: The number of volumes to skip before starting to collect the result set.
        :param int limit: The number of volumes to return.
        :return: GetAllInstancesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_volumes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_volumes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_volumes_with_http_info(self, **kwargs):  # noqa: E501
        """Get volumes that the current user has access to.  # noqa: E501

        This api gets a list of volumes that the current user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_volumes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication. Accepts a valid platform or instance token
        :param bool fetch_all_instances: Only used by Administrator, if true returns all volume instances.
        :param str id: id of the volume
        :param str display_name: query by volume name
        :param str namespace: query by namespace
        :param int offset: The number of volumes to skip before starting to collect the result set.
        :param int limit: The number of volumes to return.
        :return: GetAllInstancesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jwt_auth_user_payload', 'authorization', 'fetch_all_instances', 'id', 'display_name', 'namespace', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_volumes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fetch_all_instances' in params:
            query_params.append(('fetch_all_instances', params['fetch_all_instances']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'display_name' in params:
            query_params.append(('display_name', params['display_name']))  # noqa: E501
        if 'namespace' in params:
            query_params.append(('namespace', params['namespace']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllInstancesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def provision_volume_instance(self, body, **kwargs):  # noqa: E501
        """Provision a new volume instance.  # noqa: E501

        Can only be initiated by a user with the \"can_provision\" permission. The volume instance record includes all metadata to identify the service instance, the type of service, the \"configuration\" that included its provisioning, the user who provisioned it etc. The implementation also includes some \"operational\" aspects -such as whether the instance is ready for use etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.provision_volume_instance(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProvisionInstanceRequest body: VolumeInstance metadata artifact that needs to be added to the Database (required)
        :param str ibm_cpd_transaction_id: Unique ID that is used to identify each transaction.
        :return: InstanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.provision_volume_instance_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.provision_volume_instance_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def provision_volume_instance_with_http_info(self, body, **kwargs):  # noqa: E501
        """Provision a new volume instance.  # noqa: E501

        Can only be initiated by a user with the \"can_provision\" permission. The volume instance record includes all metadata to identify the service instance, the type of service, the \"configuration\" that included its provisioning, the user who provisioned it etc. The implementation also includes some \"operational\" aspects -such as whether the instance is ready for use etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.provision_volume_instance_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProvisionInstanceRequest body: VolumeInstance metadata artifact that needs to be added to the Database (required)
        :param str ibm_cpd_transaction_id: Unique ID that is used to identify each transaction.
        :return: InstanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ibm_cpd_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method provision_volume_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `provision_volume_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'ibm_cpd_transaction_id' in params:
            header_params['IBM-CPD-Transaction-ID'] = params['ibm_cpd_transaction_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_volume_service(self, volume_name, body, **kwargs):  # noqa: E501
        """Start a fileserver with a persistent volume  # noqa: E501

        Starts a service which contains a lightweight fileserver that supports upload, delete, list and get operations on file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_volume_service(volume_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str volume_name: name of the persistent volume. For zen-volumes, the value will be the name of the provisioned volume (required)
        :param VolumeObject body: Volume metadata. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :return: SuccessPostResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_volume_service_with_http_info(volume_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.start_volume_service_with_http_info(volume_name, body, **kwargs)  # noqa: E501
            return data

    def start_volume_service_with_http_info(self, volume_name, body, **kwargs):  # noqa: E501
        """Start a fileserver with a persistent volume  # noqa: E501

        Starts a service which contains a lightweight fileserver that supports upload, delete, list and get operations on file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_volume_service_with_http_info(volume_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str volume_name: name of the persistent volume. For zen-volumes, the value will be the name of the provisioned volume (required)
        :param VolumeObject body: Volume metadata. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :return: SuccessPostResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['volume_name', 'body', 'jwt_auth_user_payload', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_volume_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'volume_name' is set
        if ('volume_name' not in params or
                params['volume_name'] is None):
            raise ValueError("Missing the required parameter `volume_name` when calling `start_volume_service`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `start_volume_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_name' in params:
            path_params['volume_name'] = params['volume_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/volume_services/{volume_name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessPostResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_volume_service(self, volume_name, **kwargs):  # noqa: E501
        """Stop the file server service  # noqa: E501

        Stops the file server instance and deletes the deployment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_volume_service(volume_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str volume_name: name of the persistent volume (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_volume_service_with_http_info(volume_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stop_volume_service_with_http_info(volume_name, **kwargs)  # noqa: E501
            return data

    def stop_volume_service_with_http_info(self, volume_name, **kwargs):  # noqa: E501
        """Stop the file server service  # noqa: E501

        Stops the file server instance and deletes the deployment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_volume_service_with_http_info(volume_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str volume_name: name of the persistent volume (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['volume_name', 'jwt_auth_user_payload', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_volume_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'volume_name' is set
        if ('volume_name' not in params or
                params['volume_name'] is None):
            raise ValueError("Missing the required parameter `volume_name` when calling `stop_volume_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_name' in params:
            path_params['volume_name'] = params['volume_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/volume_services/{volume_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_arguments(self, display_name, body, **kwargs):  # noqa: E501
        """Update volume description and cifs credentials that the current user has access to.  # noqa: E501

        This api update target volume instance's description and cifs credentials that the current user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_arguments(display_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str display_name: name of the volume instance (required)
        :param Body6 body: (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication. Accepts a valid platform or instance token
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_arguments_with_http_info(display_name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_arguments_with_http_info(display_name, body, **kwargs)  # noqa: E501
            return data

    def update_arguments_with_http_info(self, display_name, body, **kwargs):  # noqa: E501
        """Update volume description and cifs credentials that the current user has access to.  # noqa: E501

        This api update target volume instance's description and cifs credentials that the current user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_arguments_with_http_info(display_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str display_name: name of the volume instance (required)
        :param Body6 body: (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication. Accepts a valid platform or instance token
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['display_name', 'body', 'jwt_auth_user_payload', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_arguments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'display_name' is set
        if ('display_name' not in params or
                params['display_name'] is None):
            raise ValueError("Missing the required parameter `display_name` when calling `update_arguments`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_arguments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'display_name' in params:
            path_params['display_name'] = params['display_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/{display_name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, file_path, **kwargs):  # noqa: E501
        """Upload file to the volume  # noqa: E501

        Upload a file or create a directory (if no file provided to upload) into the volume  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: Path leading upto where the file is uploaded in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param file up_file: File to be uploaded. If this field is absent then a directory with the file-path is created.
        :param bool extract: Set to true if and only if the uploaded file is to be extracted.
        :param bool make_executable: Set to true if and only if the uploaded file is to be given executable permissions.
        :param bool ignore_name_validation: Set to true if and only if the name in file_path is not to be validated/sanitized.
        :param bool keep_root_dir: Set to true if want to keep root directories in extracted zip file
        :param str volume_type: Set to pvc if want to upload file to pvc, set objectstore if want to upload file to objectstore bucket
        :param str bucket_name: Bucket must be set if volume_type is objectstore
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_with_http_info(file_path, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(file_path, **kwargs)  # noqa: E501
            return data

    def upload_file_with_http_info(self, file_path, **kwargs):  # noqa: E501
        """Upload file to the volume  # noqa: E501

        Upload a file or create a directory (if no file provided to upload) into the volume  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(file_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_path: Path leading upto where the file is uploaded in the volume. This must be url-encoded. (required)
        :param str jwt_auth_user_payload: Supplied by proxy. Do NOT add your own value.
        :param str authorization: Bearer token based authentication.
        :param file up_file: File to be uploaded. If this field is absent then a directory with the file-path is created.
        :param bool extract: Set to true if and only if the uploaded file is to be extracted.
        :param bool make_executable: Set to true if and only if the uploaded file is to be given executable permissions.
        :param bool ignore_name_validation: Set to true if and only if the name in file_path is not to be validated/sanitized.
        :param bool keep_root_dir: Set to true if want to keep root directories in extracted zip file
        :param str volume_type: Set to pvc if want to upload file to pvc, set objectstore if want to upload file to objectstore bucket
        :param str bucket_name: Bucket must be set if volume_type is objectstore
        :return: SuccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_path', 'jwt_auth_user_payload', 'authorization', 'up_file', 'extract', 'make_executable', 'ignore_name_validation', 'keep_root_dir', 'volume_type', 'bucket_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_path' is set
        if ('file_path' not in params or
                params['file_path'] is None):
            raise ValueError("Missing the required parameter `file_path` when calling `upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_path' in params:
            path_params['file_path'] = params['file_path']  # noqa: E501

        query_params = []
        if 'extract' in params:
            query_params.append(('extract', params['extract']))  # noqa: E501
        if 'make_executable' in params:
            query_params.append(('make_executable', params['make_executable']))  # noqa: E501
        if 'ignore_name_validation' in params:
            query_params.append(('ignore_name_validation', params['ignore_name_validation']))  # noqa: E501
        if 'keep_root_dir' in params:
            query_params.append(('keep_root_dir', params['keep_root_dir']))  # noqa: E501
        if 'volume_type' in params:
            query_params.append(('volume_type', params['volume_type']))  # noqa: E501
        if 'bucket_name' in params:
            query_params.append(('bucket_name', params['bucket_name']))  # noqa: E501

        header_params = {}
        if 'jwt_auth_user_payload' in params:
            header_params['jwt-auth-user-payload'] = params['jwt_auth_user_payload']  # noqa: E501
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'up_file' in params:
            local_var_files['upFile'] = params['up_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/volumes/files/{file_path}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
